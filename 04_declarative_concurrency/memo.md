# 4. 宣言的並行性

- concurrentなプログラム
    - 独立に実行するアクティビティの集合
    - 必要なときにだけ相互に働きかける
- 宣言的モデルだけでは容易にor効率的に書けない
    - 拡張して並行性を追加
    - **プログラミング技法と推論技法はそのまま適用できる**
    - point: データフロー変数はただ1つの値にしか束縛できない
        - **観測可能な非決定性**が存在しないため　

## 4.1. データ駆動並列モデル

- 宣言的計算モデルに並行性を追加するステップ
    1. スレッドと、命令`thread <s> end`を追加
        - **データ駆動平行モデル**: 宣言的モデル+並行性
    2. 別の実行順序( **by-needトリガ**)の追加
        - **要求駆動計算**, 遅延実行が可能に
        - **要求駆動平行モデル**、 **遅延平行モデル**

### 4.1.1. 基本概念

- 2つ以上の実行文が、(同時に)格納域を参照できるようにする
- スレッド == 複数意味スタック

#### インタリーブ

- 「同時に」
    - 言語視点
        - プログラマから見た言語の意味
        - スレッドに **インタリーブ実行**をさせることで仮定
            - 計算ステップの列を、各スレッドが交代に実行する
            - 各計算ステップがatomicに各スレッド上で実行される
            - 推論を容易に
    - 実装視点
        - 現実のマシン上で複数スレッドがどう実装されるか
        - シングルプロセッサ: インタリーブにスレッドが実装されうる
        - マルチプロセッサ: 複数のスレッドが同時に複数の計算ステップを処理、性能改善
- point: **インタリーブ意味**
    - 実装がどうであれ、インタリーブ実行されるものが少なくとも１つは存在している
    - 格納域を監視していると、同じように成長するようなインタリーブ実行を見出せる

#### 因果順序

- 直列と平行: プログラムの実行状態の間に定義される順序から見る
    - 直列: 全順序、一直線に処理される
    - 平行: スレッド内は全順序、プログラム全体では半順序
- 因果順序: 半順序で実行されるプログラムの中で、ステップの一方がデータフロー変数xを束縛し、他方がxの値を必要とすること
- 因果順序に応じて、ステップが実行される順序のパターンが絞られる

#### 非決定性

- 非決定性な実行
    - 次にすることを選択すべき状態が現れるような実行
    - どのスレッドを実行するか途中で選択する必要がある状態
- 宣言的平行モデルにおいて、非決定性はプログラマに見えない
    - データフロー変数が束縛されるのはただ1つの値だけであるため
        - 非決定性の影響を受けるのは束縛のタイミング
        - 束縛が行われる、という事実自体に変わりはない
    - ある変数が必要などんな操作も、束縛を待つ以外にできることはないため

#### スケジューリング

- スケジューラが単調である: 準備完了のスレッドはいつでも実行できる
- fairなシステム
    - 準備完了のどんなスレッドも餓死させない
    - 準備完了のスレッドはいずれ実行される
    - スレッドの実行が他のスレッドの実行に依存していない
    - 推論が容易、モジュラ性

### 4.1.2. スレッドの意味

- 並行処理: 複数の意味スタック(スレッド)を持つ
- 全ての意味スタックは同じ格納域にアクセスする
- スレッド間の通信は、共有格納域を通じて行う

#### 概念

- 復習
    - 単一代入格納域`σ`
    - 環境`E`
    - 意味言明`(<s>,E)`
    - 意味スタック`ST`
- 実行状態
    - `(MST, σ)`
    - MST: multiset、同じ要素を2つ以上含みうる集合
        - 異なる意味スタック上で同一の文を実行する場合がある

#### プログラム実行

- スケジューリングアルゴリズム、fairなシステムを実現する

#### thread文

- multisetをどう変化させるか、に着目して定義
- 新しいスレッドに対応する新しい意味スタックを追加する

#### メモリ管理

- 終了した意味スタック
    - 開放する
- ブロックした意味スタック
    - 活性化条件が到達不能な変数に依存する場合、再利用される
- ※第2章の下記文言は正しいとはいえない
    - > 制御構造は開放され、データ構造は再利用される

### 4.1.3. 実行例

### 4.1.4. 宣言的並行性とは何か？

- データ駆動平行モデルはなぜ宣言的プログラミングの１つと言えるのか
    - 宣言的プログラミング: 出力が入力の数学的関数であるべき
        - 関数型の例: 入力値について計算し、終了したときに出力値を返す
    - データ駆動の場合: 関数型と違いがある
        - 入力と出力は値とは限らない
            - 束縛されていない値を含む部分値のことがある
        - 実行が終了しないかもしれない
            - 入力が無限に成長するストリームのことがある

#### 部分停止

- 実行が終了しない例
- **部分停止**: 入力の成長が止まればプログラムが終了すること
- 完全に停止したわけではない、これからの束縛によっては再開するかもしれない

#### 論理的同値

- 「出力が入力の関数である」とは？
    - 「同じ」であることの定義が必要
- **論理的同値**
    - **制約**: 格納域変数が同じ値を参照するような束縛の集合のこと
    ```
    i.  X=1 Y=X
    ii. Y=X X=1
    ```
    - `values(x,c)`: 変数xと制約cについて、cが成立しているときにxが取りうるすべての値の集合
```
2つの制約c1, c2とが「論理的に同値である」とは、
    - 両方が同じ変数を含み、
    - 各変数xについてvalues(x,c1)=values(x,c2)となる
こと
```

#### 宣言的並行性

- 並行的プログラムが宣言的であるということ
    - 全ての実行の仕方が同じ結果を出して終わらなければならない
    - 論理的に同じである, 各変数が同じものに束縛されるわけではない

```
並行的プログラムが宣言的であるとは、可能なすべての入力に対して、次が成り立つこと。
- 与えられた入力の集合に対する全ての実行が、次の2つのどちらかの結果になる。
    - すべて停止しない
    - いずれ部分停止に至り、論理的に同値な結果を出す
```
- 目に見える非決定性は存在しない

- 遅延実行、性急実行ともに有効
- 非宣言的モデルを導入する際の判断基準になる
    - 非宣言的プログラムの一部に本定義が当てはまる際、残りのプログラムに対して宣言的であると言える

- データ駆動平行モデルは宣言的
- 要求駆動平行モデル(データ駆動平行モデルより一般的)も宣言的と言える

#### 失敗

- 格納域の中に矛盾する情報を格納しようとするときに生じる、宣言的プログラムの異常終了
- 特定の入力に対して失敗が起こったら、どんな実行方法でも失敗するべき(数学的関数)
- 失敗によってプログラムを終了させず、誤りを報告して実行し続けたい
    - **例外**の利用
    - 例外を使うと **宣言的でなくなる**
        - 格納域の内容: 例外発生の直前のもの
        - 実行の仕方によって、処理がどこまで行われたか=格納域の内容が変わる
        - 観測可能な非決定性

#### 失敗の閉じ込め

- 失敗の後で実行を再び宣言的にしたい => 非決定性を隠す
    - 例外が発生したら、変数をデフォルト値に束縛されるようにする

## 4.2 スレッドプログラミングの基本的技法

### 4.2.1. スレッドを生成すること

- `thread`文でスレッドを生成する
```
declare X in
local Y in
    thread Y=10*10 end
    X=Y+100*100
end
```
- メインスレッドと新しいスレッド間の通信のため、データフロー変数Yが生成
- スレッドの実行: 横取り方式(preemptive)で実装
- 2つ以上のスレッドが準備完了のとき、 **タイムスライス** 間隔でプロセッサの時間を使う

### 4.2.2. スレッドとブラウザ

### 4.2.3. スレッドを使うデータフロー計算

- 各スレッドはデータフロースレッド、データが使えるようになるまで待つことがある

#### 単純なデータフローでの振る舞い

#### 平行的状況で宣言的プログラムを使うこと

- 直列の場合と実行結果は同じ
- バッチ的実行

#### データフローとゴム紐

#### 安価な並行性とプログラム構造

- スレッドの使用: モジュール化を進めるなど、プログラム構造の改良に繋がる事が多い
    - ほとんどの大きなプログラムにはスレッド化による改良の余地がある
- あまり資源を使わないスレッド化が良い
- 直列はどんな安価なスレッドを用いた平行よりも安価
- 必要としない限りスレッド化は避けるべき
- 構造の改良に貢献するのであればどんどんスレッド化すべき

### 4.2.4. スレッドのスケジューリング

- スケジューラの責務とその方法

#### タイムスライス

- **ラウンドロビン方式**
    - やり方
        - 全ての準備完了スレッドをキューに入れる
        - 各ステップにおいて、キューから最初のスレッドを取り出して数ステップ実行させる
        - キューに戻す
    - プロセッサ時間が、各準備完了スレッドに公平に割り振られることが保証
    - スレッドをキューから取り出し、再度キューに戻すのはコストがかかる
        - キュー管理のオーバーヘッド
        - (?:できるだけスレッドは大きめに処理をくくった方が良い？)
    - 一度取り出したスレッドにできるだけ多くの計算ステップを実行させる
- **タイムスライス**, **クォンタム**
    - 各スレッドが持つ最大時間間隔
    - 超えない範囲で計算ステップを実行できる
- **横取り**
    - スレッドのタイムスライスが尽き、スケジューラがそのスレッドの実行を停めること
    - スレッドはキューに戻される
- 各スレッドがプロセッサ時間を同じ割合で使用するようにする方法
    - **計数法**
        - スレッドの計算ステップを数え、同数の単位時間を与える
        - 決定性である
        - タイミングの保証が重要なアプリに使用
    - **タイマ法**
        - ハードウェアタイマを使ってスレッドに同じ時間を与える
        - 効率がいい
        - 決定性でない: OS内の様々なイベントが影響を及ぼしうる

#### 優先順位レベル

- うまくスレッド間のプロセッサ時間分配を調整する必要がある
    - 緊急で処理すべきイベントが発生するかもしれない
- スレッドに **優先順位レベル** を与える

#### 優先順位の継承

- 新しく作成されたスレッドは、親と同じ優先順位が与えられる
- 子スレッドのレベルは親より低くてはならない
    - そのスレッドのレベルが引き上げられるまでに、何度もリスケされるコストが発生する恐れがあるため

#### タイムスライスの長さ

- 横取りをどう実装するか
    - 内部的
    - 外部的
        - こちらの方が実装しやすい
- 10ミリ秒のタイムスライスでも長すぎるアプリ
    - 多くのスレッドを持つ場合、スレッド同士は強く相互に依存している
    - どのスレッドも別のスレッドに譲るまで、タイムスライスを使い切らない
- タイムスライスが短すぎるアプリ
    - スレッドが他のスレッドと独立に外部と相互作用するもの(?:例)
    - 厳しいリアルタイムコンピューティングシステムが必要
    - 特殊なハードウェアとOSを要する

### 4.2.5. 協調的並行性と競合的並行性

- スレッド: 協調的並行性を意図したもの
- 協調的並行性
    - ある全体的な目的を目指してともに働く実体
    - スレッド: 全てが3つの優先順位レベルの間で時間の割合を変えることができる
    - 全ての部分が信頼しあって走るアプリのためのもの
- 競合的並行性
    - それぞれの目的を持ち、自分自身のために働く実体
    - 自身の性能にのみ興味があり、全体的な性能を鑑みない
    - OSがプロセスをもって管理する
- 計算の持つ2層構造

```
OS --- Process/App(競合的並行性: アプリごとに異なる目的を持つ)
        -- Threadの集合(協調的並行性: 相互に作用し、同一の目的のために協調的に実行される)
    -- Process/App
        -- Threadの集合
```

### 4.2.6. スレッド操作

---

## 4.3. ストリーム

- ストリーム
    - スレッド間通信を行う
    - 果てしなく続く可能性のあるメッセージのリスト
        - 束縛されていないデータフロー変数を末尾に持つリスト
    - 1つの要素を追加してストリームを伸ばすことで、メッセージを送る
        - 対`Message|未束縛の変数`を末尾に追加する
- 能動的オブジェクト(ストリームオブジェクト)
    - ストリームを通じて通信するオブジェクト
    - 各変数は1つのスレッドにしか束縛されていない
        - **ロック** や **相互排除** は不要
- 決定性ストリームプログラム
    - どのストリームオブジェクトも、次のメッセージがどこから来るかを常に知っていること

### 4.3.1. 基本的生産者/消費者

- theme
    - ストリームがどのように働くか
    - 非同期の生産者・消費者をストリームを使ってどのようにプログラムするか

```
declare Xs Xs2 in
Xs=0|1|2|3|4|Xs2
```

- Producerと呼ばれる1つのスレッドがストリームを生成する
- Consumerと呼ばれる1つ以上のスレッドがストリームを読む
- Consumerはストリームが生成されるに従って読む
    - ストリームの末尾はデータフロー変数
- ConsumerをProducerに同期させる
    - データフロー変数の束縛を待つ
    - `case`文で、次のストリーム要素が到着するまで、実行をブロックする
- (?: `Producer/Consumer`と`Publisher/Subcriber`は同義？何か意図して別のものを指すことがある？)

#### 高階イテレータを使用すること

- ループ抽象、高階イテレータを使ってアキュムレータを取り除く
    - 実際はイテレータの中に隠れただけ
    - プログラマは状態に基づいて推論しなくて良くなる

#### 複数の消費者

- 複数のConsumerを導入する
- 他のConsumerとは独立してストリームを購読する

### 4.3.2. 変換器とパイプライン

- 第3のストリームオブジェクト
    - Producerのストリームを読んで、Consumerが読む別のストリームを生成する
    - **変換器(transducer)**
- **パイプライン(Pipeline)**
    - 次々にストリームを供給していくストリームオブジェクトの列
- **ソース(Source)**
    - パイプラインの先頭(Producer)
- **シンク(Sink)**
    - パイプラインの最後(Consumer)

#### ストリームのフィルタリング

- **filter**
    - 入力ストリームの要素で、ある条件を満たすものだけを出力する
    - 第3章 `Filter`を呼ぶ

#### エラトステネスの篩

- エラトステネスの篩(sieve)
    - 素数だけを含むストリームを出力する
    - 素数だけになるまで、非素数をストリームからフィルタリングしていく
    - 方法
        - 2から始まる連続整数のストリームを生成する
        - 要素を1つ取り出し、その倍数を取り去るフィルタを生成する
        - 残りを要素とするストリームについて自分自身を再帰的に呼ぶ

### 4.3.3. 資源を管理し、処理能力を改善すること

- Consumerが処理できないほど速くProducerがストリームを生産したときにどうするか
    - 消費しきれない要素が資源を独占するのを防ぐ
    - 解決策のひとつ: Producerの要素生成率を抑える: **フロー制御(flow control)**
    - 消費者から生産者へ何らかの情報を返す必要がある
        - eg. 資源の最大利用量

#### 4.3.3.1. 要素駆動並行性によるフロー制御

- **要素駆動並行性** **遅延実行**
    - もっとも簡単なフロー制御
    - Producerは、Consumerが明示的に要求したときだけ要素を生成する
        - cf. 供給駆動実行、性急実行: Producerが自分の好きなときにいつでも要素を生成する技法
    - 遅延実行: 消費者が要素を必要とするときに生産者に合図する機構が必要
        - データフローを使う
        - eg. Consumerは要素が必要なときに入力ストリームを伸ばす
        - (?: 要素を追加するのってProducerのお仕事なのでは？)
        - 要素がいくつ要るのかを制御するのはConsumer(`DSum`の引数で指定する)
        - 遅延実行を明示的トリガを使って実装する例
        - 暗黙的トリガの方が実装しやすいらしい

#### 4.3.3.2. 有界バッファを使うフロー制御

- ストリーム通信を管理する2つの技法
    - 性急実行
        - Producerは完全に自由
        - Consumerが処理しているものよりずっと多くの要素を生成していても構わない
        - => 資源使用の爆発的増大
    - 遅延実行
        - Producerは制約されている
        - Consumerから明示的な要求が来ない限り、要素を生成できない
        - => **処理能力(throughput)**の大幅な減少
            - 単位時間あたりに送ることができるメッセージ数
            - **待ち時間**と対象を成す
                - 1つのメッセージが送信されてから受信されるまでに要する時間
            - Consumerがメッセージを要求してProducerが要素を生成する間、Consumerは待たされる
            - ProducerがConsumerの先を行ければ、Consumerは待たなくて済む
- **有界バッファ(bounded buffer)**
    - 資源問題を回避し、スループットを落とさない方法
    - 性急実行と遅延実行を組み合わせる
    - 変換器、最大値`n`までの要素を格納する
    - Producerは有界バッファがいっぱいになるまで要素を生成できる
        - 余分な資源利用量は`n`
    - Consumerはいちいち要素の生成を待たずに取り出せる
        - スループットを高く保つ
    - バッファの量が`n`を下回ったら、Producerは最大値まで要素を生成してよい

```
proc {Buffer N ?Xs Ys}
   fun {Startup N ?Xs}
      if N==0 then Xs
      else Xr in Xs=_|Xr {Startup N-1 Xr} end
   end

   proc {AskLoop Ys ?Xs ?End}
      case Ys of Y|Yr then Xr End2 in
	 Xs=Y|Xr    % バッファから要素を取り出す
	 End=_|End2 % バッファに補充する
	 {AskLoop Yr Xr End2}
      end
   end
   End={Startup N Xs}
in
   {AskLoop Ys Xs End}
end
```

- `Xs`と`Ys`は遅延ストリームである
- バッファの実行
    1. 初期化
        - `Startup`を呼んで、Producerに`n`個の要素を要求する
        - 束縛されていない`n`個の変数を`Xs`に追加する
        - Producerは要求を検知し、`n`要素を生成する
    2. バッファ管理
        - `AskLoop`を呼ぶ
        - Consumerが要素を要求する度に下記を行う
            - バッファから要素を取ってConsumerに渡す
            - バッファに補充するため、Producerに要素を要求する
- バッファ`Xs`は常に`Ys`より4つ多くなる
- 有界バッファのプログラムを書く/理解する上で困難な点
    - 多くの辻褄合わせが必要
        - 技術的な理由
        - (?: バッファのpub/subとの繋ぎ込みの部分のこと？)
        - Producer, Consumerをどう書くかには影響ない
        - => 計算モデルを拡張すれば、もっと遅延をうまく実装できる！(暗黙の遅延)
- この節の有界バッファの欠点
    - 何も格納しなくても、`O(n)`のメモリを費やす
        - Producerが最後まで要素を生成しきるのが遅いため
        - 束縛されていない`n`個のリスト要素を保持する
    - 第6章 明示的状態を使えば改善できる
- 有界バッファの極端な場合
    - バッファの大きさが無限大: 性急実行
    - バッファの大きさがゼロ  : 遅延実行

#### 4.3.3.3. スレッドの優先順位を利用するフロー制御

- Producer, Consumerそれぞれのスレッドに優先順位の差を設け、相対速度に対応できるようにする
- あくまで有界バッファの使用が最善
    - 脆さがあるため
    - Producer, Consumerそれぞれの仕事量&各スレッドの速度比&他のスレッドに成功が依存する

### 4.3.4. ストリームオブジェクト

- 並列プログラム: ストリームを通じて通信するスレッドのネットワークとして書く
- **ストリームオブジェクト**
    - 自身スレッドとして実行する再帰手続き
    - 他のストリームオブジェクトと、入力ストリーム/出力ストリームを通じて通信
    - 内部状態を引数として持つ: *アキュムレータ*
    - 値と操作をひとまとめにした1つの実体: オブジェクト
        - cf. ADT: 値と操作は別々の実体
    - 内部状態を持ち、ストリーム上のメッセージによって統制のとれた方法でアクセス

### 4.3.5. ディジタル論理のシミュレーション

- **同期的プログラミング**
    - ストリームオブジェクトの有向グラフを使う
    - グラフを構成するすべてのストリームオブジェクトが相互に同期を取っている
- 線形連鎖ではないグラフの例: ディジタル論理のシミュレーション

## 4.4. 宣言的平行モデルを直接使うこと

- ストリームの概念を用いず、宣言的平行モデルを使ってプログラムする例

### 4.4.1. 順序決定並行性

- 宣言的プログラムの中での平行実行
    - 計算の順序を見つけること
    - 正しい順序通りにプログラムが計算するようにする: データフロー並行性
    - 方法
        - プログラマが順序を推測し、それに従ってプログラムする
            - 効率がいい
            - ミスがあるとデッドロックが発生する
        - システムが動的に順序を推測する
            - 各計算を別のスレッドにし、データフロー実行を行う
            - 束縛に応じて、実行可能状態にあるものから実行されていく

### 4.4.2. コルーチン

- 横取りなしのスレッド
- 新しい命令の実行列(制御の軌跡)をもつ
- スレッドと異なり、プログラムの中で明示的に実行の切り替えを行う
    - スレッドは暗黙的(プログラムではなくシステムによって)切り替え
- 操作
    - `Spawn`
    - `Resume`
- プログラマのミスで、実行機会の失われた実行列が生まれうる: **餓死**
- 実装には明示的状態が必要
    - cf. **状態共有平行モデル**

### 4.4.3. 並行的合成

- forkしたスレッドを元に戻す(join)
    - 別スレッドの終了をどうやって検知するのか
- 変数束縛を待つやり方
- 補助のスレッド(各スレッドの実行状態のみを司るスレッド)を使うやり方

#### 制御抽象

- 並行的合成を実装する **組み合わせ操作**: `Barrier`

## 4.5. 遅延実行

- プログラムの実行順序
    - 左から右へ
        - **性急計算**, **データ駆動計算**
    - 他のところで必要になってから
        - **遅延計算**, **要求駆動計算**
- keyword: `lazy`

#### 遅延実行の重要性

- 小規模プログラム
    - 良好な償却的、最悪時間限界を持つ宣言的アルゴリズムを設計するのに役立つ
- 大規模プログラム
    - プログラムのモジュール化に役立つ

### 4.5.1. 要求駆動平行モデル

- データ駆動平行モデルに **by-needトリガ**を追加したもの
- 宣言的並行性の条件を満たす
- データ駆動平行モデルと要求駆動平行モデルは共存できる
    - デフォルトはデータ駆動平衡モデルにすべき
    - 推論が容易
    - 効率的に実装できる
- 動的リンクの実装などに役立つ
    - モジュールへのアクセス(必要とすること)を通じてリンクされる(メモリにロードされ、具体化)

#### by-needトリガ

- `{ByNeed P Y}`
- `thread`と似てる
- 違いは、`Y`が必要にならないと実行されないこと

#### by-needトリガのsemantics

- 活性化条件と手続きの対
- 明示的トリガ(プログラムされたもの)と暗黙的トリガ(計算モデルの一部)
- ステップ
    - 実行状態にトリガ格納域を付加
    - トリガ生成
    - トリガ活性化

#### メモリ管理

- 到達可能性
    - `trig(x, y)`の存在と`y`への到達可能性

### 4.5.2. 宣言的計算モデル

- 遅延性と並行性
- 言語は双方を持ったりどちらかを持ったりすることができる

#### なぜデータフローを伴う遅延性は平行でなければならないか

- データフロー変数により、直列だとデッドロックが発生する恐れがあるから
- `suspend`しても、平行で該当の処理を必要とするような処理を行っている
- 依然として宣言的: 観測可能な非決定性が存在しない

### 4.5.3. 遅延ストリーム

- 性急実行と遅延実行のトレードオフ
    - 多数〜無限のリストを扱う、大量の資源を使うとき: 遅延実行
    - 遅延実行の実装にかかる費用は性急実行よりも高い
- 実装方法
    - プログラムされたトリガ
        - トリガメッセージを辻褄合わせする必要がある
            - ConsumerからProducerへの通知を行うケース
            - 実装が面倒
    - 暗黙的トリガ

#### 遅延関数を宣言すること

- 関数のデフォルトの挙動
    - 遅延関数型言語: 遅延
    - 要求駆動平行モデル: 性急、`lazy`キーワードによって遅延であることを明示
- デフォルトは性急であるべき
    - 効率とコンパイル
        - 性急実行はトリガ機構がないため効率がいい
        - 遅延関数型言語で性急実行を実現するには、コンパイラの判断が必要
            - 正格性解析
    - 言語設計
        - 性急言語の方が非宣言的概念(例外、状態)などの追加に開けている

### 4.5.7. 遅延リスト操作

- **漸増的**な関数
    - だんだん増える関数
    - 一度に1つの要素を効率よく生成する
- **一枚岩**な関数
    - 1つの要素を生成するのに、全体が生成できるような労力を要する
    - リストを逆転させる関数など

### 4.5.8. 永続的キューとアルゴリズム設計

- 3.4.5節 キュー: 単用的(ephemeral)
    - 入力されたリストは再利用されず、必ず新たに生成されたものが出力される
    - 一度に1つの版しか存在しない
- 永続的キュー
    - 複数の版が存在する
    - (?: 単用的なキューと比較した際のうまみは？)
- 実装
    - 逆転をどう扱うか
        - 一枚岩でコストのかかる関数
        - コストを操作数で分解し、償却的にする必要がある
            - 遅延関数を利用

#### 4.5.8.3. アルゴリズム設計に対する教訓

- 遅延は宣言的アルゴリズムを設計するための強力なツール
    - 結果を変えずに計算を部分的に入れ替えることができる
- 注意点
    - 素朴に利用すると、最悪時限界を償却的限界にしてしまう
    - ちゃんと使うと、償却的アルゴリズムを改良できる
- point
    - 高価な操作を漸増的なものとしてばらまくこと

### 4.5.9. リスト内包記法

- ストリームを定義するための便宜的記法
- ストリームの区分
    - 有界である(=リスト)
    - 潜在的に有界でない
        - 遅延的に計算すると有利になることが多い
- リスト内包記法
    - 集合の数学的内包記法によく似ている
        - `{x*y|1<=x<=10, 1<=y<=x}`
    - `[f(x)|x<-generator(a1,...,an), guard(x,a1,...,an)]`

## 4.6. 甘いリアルタイムプログラミング

## 4.7. Haskell言語

## 4.8. 宣言的プログラムの限界と拡張

- 効率的である
    - アセンブリ言語で書くのと比べて性能が定数倍程度
- 自然である
    - 問題に関係のない、技術的な理由だけから必要とされるコードがわずかであること
    - モジュラ性、非決定性、現実世界とのインタフェース
    - 自然性が問題でなければ、宣言的モデルや直列版を使うべき
        - 正しく、効率的なコンポーネントを実装可能

### 4.8.1. 効率性

- 宣言的モデルと標準的コンピュータの間のミスマッチ
    - コンピュータ: データをその場で修正する
    - 宣言的モデル: 常に新しいデータを生成する
- 宣言的モデルを普通の代入を用いて実装する->コンパイラの出来しだい
- 宣言的モデルを標準的コンピュータに写像する
    - コンパイラにプログラムを書き直させること
    - 凡用プログラム向けのコンパイラには不可
- 自然さを犠牲にしてよければ、宣言的プログラミングは効率的: 両立は不可能
    - 大きなデータ構造を漸増的に修正するプログラムは一般的に効率的にコンパイルできない
    - **メモ化**: 以前に計算した結果を内部キャッシュする、効率化
    - 状態ありプログラミングより表現性に乏しいため、同一の効率でもより複雑になる

### 4.8.2. モジュラ性

- **modula**: プログラムの他の部分を変更せずに、意図した変更が行えること
- 宣言的モデルにおいては得られない
    - 明示的状態が必要
    - メモ化キャッシュはモジュラ性でない。関数の外の多くの場所でアキュムレーターをスレッド化する必要があるため。
    - プログラムの **計器化**。コンポーネントの呼ばれる回数を数えたい、などのとき。
        - 手続き呼び出しの間でスレッド化が必要、多くの変更が発生する
        - 状態ありモデルを導入してもいい
- 状態ありモデルはモジュラ性の高い実装が簡単
    - 追加した操作にかかわらず、I/Fは一定
- 宣言的方法は余分な引数受け渡しが多く、遅い。

- プリプロセッサの落とし穴
    - 状態ありモデルを宣言的に変換するプリプロセッサがあってもいい？
        - 結局意味ない、非効率的な実装にすぎない
        - 推論が困難
        - 引数の受け渡しが増える

### 4.8.3. 決定性

- 平行プログラムにおいて、常に決定的であることは言語的限界を生み出している
- 真に独立なコンポーネントは相互に非決定性にふるまうため
- 非決定性を付加し、宣言的でなくする
    - クライアント/サーバーアプリケーションの例
        - `WaitTwo`、非決定性待ち操作の実装
    - ビデオディスプレイアプリケーションの例
        - `IsDet`、データフロー変数の束縛をチェックする

### 4.8.4. 現実世界

- 現実世界には状態や並行性がある: 宣言的でない
- *インターフェース問題*
    - 宣言的コンポーネントは、非宣言的コンポーネントとのインターフェースを表せない
    - ハード、UI、OSとのインターフェースは宣言的にできない
- *仕様問題*
    - 現実世界の問題を解決するための仕様を、宣言的に表現する必要が出てくる

### 4.8.5. 正しいモデルを選ぶ

- 推論のしやすさ、表現力のトレードオフ
- **最小表現力規則**
    - あるコンポーネントをプログラムするとき、そのコンポーネントにとって正しい計算モデルは、自然なプログラムが書けるようなモデルで、表現力最小のものである。
- 自然な: 主観的

### 4.8.7. 異なるモデルを一緒に使うこと

- インピーダンス・マッチングを使って実装
    - 関心の分離を実装するよい方法
- 正しい抽象を見つけ、実装する
    - 正しく、適当なモデルの棲み分けを見つけること

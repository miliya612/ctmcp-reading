# 4. 宣言的並行性

- concurrentなプログラム
    - 独立に実行するアクティビティの集合
    - 必要なときにだけ相互に働きかける
- 宣言的モデルだけでは容易にor効率的に書けない
    - 拡張して並行性を追加
    - **プログラミング技法と推論技法はそのまま適用できる**
    - point: データフロー変数はただ1つの値にしか束縛できない
        - **観測可能な非決定性**が存在しないため　

## 4.1. データ駆動並列モデル

- 宣言的計算モデルに並行性を追加するステップ
    1. スレッドと、命令`thread <s> end`を追加
        - **データ駆動平行モデル**: 宣言的モデル+並行性
    2. 別の実行順序( **by-needトリガ**)の追加
        - **要求駆動計算**, 遅延実行が可能に
        - **要求駆動平行モデル**、 **遅延平行モデル**

### 4.1.1. 基本概念

- 2つ以上の実行文が、(同時に)格納域を参照できるようにする
- スレッド == 複数意味スタック

#### インタリーブ

- 「同時に」
    - 言語視点
        - プログラマから見た言語の意味
        - スレッドに **インタリーブ実行**をさせることで仮定
            - 計算ステップの列を、各スレッドが交代に実行する
            - 各計算ステップがatomicに各スレッド上で実行される
            - 推論を容易に
    - 実装視点
        - 現実のマシン上で複数スレッドがどう実装されるか
        - シングルプロセッサ: インタリーブにスレッドが実装されうる
        - マルチプロセッサ: 複数のスレッドが同時に複数の計算ステップを処理、性能改善
- point: **インタリーブ意味**
    - 実装がどうであれ、インタリーブ実行されるものが少なくとも１つは存在している
    - 格納域を監視していると、同じように成長するようなインタリーブ実行を見出せる

#### 因果順序

- 直列と平行: プログラムの実行状態の間に定義される順序から見る
    - 直列: 全順序、一直線に処理される
    - 平行: スレッド内は全順序、プログラム全体では半順序
- 因果順序: 半順序で実行されるプログラムの中で、ステップの一方がデータフロー変数xを束縛し、他方がxの値を必要とすること
- 因果順序に応じて、ステップが実行される順序のパターンが絞られる

#### 非決定性

- 非決定性な実行
    - 次にすることを選択すべき状態が現れるような実行
    - どのスレッドを実行するか途中で選択する必要がある状態
- 宣言的平行モデルにおいて、非決定性はプログラマに見えない
    - データフロー変数が束縛されるのはただ1つの値だけであるため
        - 非決定性の影響を受けるのは束縛のタイミング
        - 束縛が行われる、という事実自体に変わりはない
    - ある変数が必要などんな操作も、束縛を待つ以外にできることはないため

#### スケジューリング

- スケジューラが単調である: 準備完了のスレッドはいつでも実行できる
- fairなシステム
    - 準備完了のどんなスレッドも餓死させない
    - 準備完了のスレッドはいずれ実行される
    - スレッドの実行が他のスレッドの実行に依存していない
    - 推論が容易、モジュラ性

### 4.1.2. スレッドの意味

- 並行処理: 複数の意味スタック(スレッド)を持つ
- 全ての意味スタックは同じ格納域にアクセスする
- スレッド間の通信は、共有格納域を通じて行う

#### 概念

- 復習
    - 単一代入格納域`σ`
    - 環境`E`
    - 意味言明`(<s>,E)`
    - 意味スタック`ST`
- 実行状態
    - `(MST, σ)`
    - MST: multiset、同じ要素を2つ以上含みうる集合
        - 異なる意味スタック上で同一の文を実行する場合がある

#### プログラム実行

- スケジューリングアルゴリズム、fairなシステムを実現する

#### thread文

- multisetをどう変化させるか、に着目して定義
- 新しいスレッドに対応する新しい意味スタックを追加する

#### メモリ管理

- 終了した意味スタック
    - 開放する
- ブロックした意味スタック
    - 活性化条件が到達不能な変数に依存する場合、再利用される
- ※第2章の下記文言は正しいとはいえない
    - > 制御構造は開放され、データ構造は再利用される

### 4.1.3. 実行例

### 4.1.4. 宣言的並行性とは何か？

- データ駆動平行モデルはなぜ宣言的プログラミングの１つと言えるのか
    - 宣言的プログラミング: 出力が入力の数学的関数であるべき
        - 関数型の例: 入力値について計算し、終了したときに出力値を返す
    - データ駆動の場合: 関数型と違いがある
        - 入力と出力は値とは限らない
            - 束縛されていない値を含む部分値のことがある
        - 実行が終了しないかもしれない
            - 入力が無限に成長するストリームのことがある

#### 部分停止

- 実行が終了しない例
- **部分停止**: 入力の成長が止まればプログラムが終了すること
- 完全に停止したわけではない、これからの束縛によっては再開するかもしれない

#### 論理的同値

- 「出力が入力の関数である」とは？
    - 「同じ」であることの定義が必要
- **論理的同値**
    - **制約**: 格納域変数が同じ値を参照するような束縛の集合のこと
    ```
    i.  X=1 Y=X
    ii. Y=X X=1
    ```
    - `values(x,c)`: 変数xと制約cについて、cが成立しているときにxが取りうるすべての値の集合
```
2つの制約c1, c2とが「論理的に同値である」とは、
    - 両方が同じ変数を含み、
    - 各変数xについてvalues(x,c1)=values(x,c2)となる
こと
```

#### 宣言的並行性

- 並行的プログラムが宣言的であるということ
    - 全ての実行の仕方が同じ結果を出して終わらなければならない
    - 論理的に同じである, 各変数が同じものに束縛されるわけではない

```
並行的プログラムが宣言的であるとは、可能なすべての入力に対して、次が成り立つこと。
- 与えられた入力の集合に対する全ての実行が、次の2つのどちらかの結果になる。
    - すべて停止しない
    - いずれ部分停止に至り、論理的に同値な結果を出す
```
- 目に見える非決定性は存在しない

- 遅延実行、性急実行ともに有効
- 非宣言的モデルを導入する際の判断基準になる
    - 非宣言的プログラムの一部に本定義が当てはまる際、残りのプログラムに対して宣言的であると言える

- データ駆動平行モデルは宣言的
- 要求駆動平行モデル(データ駆動平行モデルより一般的)も宣言的と言える

#### 失敗

- 格納域の中に矛盾する情報を格納しようとするときに生じる、宣言的プログラムの異常終了
- 特定の入力に対して失敗が起こったら、どんな実行方法でも失敗するべき(数学的関数)
- 失敗によってプログラムを終了させず、誤りを報告して実行し続けたい
    - **例外**の利用
    - 例外を使うと **宣言的でなくなる**
        - 格納域の内容: 例外発生の直前のもの
        - 実行の仕方によって、処理がどこまで行われたか=格納域の内容が変わる
        - 観測可能な非決定性

#### 失敗の閉じ込め

- 失敗の後で実行を再び宣言的にしたい => 非決定性を隠す
    - 例外が発生したら、変数をデフォルト値に束縛されるようにする

## 4.2 スレッドプログラミングの基本的技法

### 4.2.1. スレッドを生成すること

- `thread`文でスレッドを生成する
```
declare X in
local Y in
    thread Y=10*10 end
    X=Y+100*100
end
```
- メインスレッドと新しいスレッド間の通信のため、データフロー変数Yが生成
- スレッドの実行: 横取り方式(preemptive)で実装
- 2つ以上のスレッドが準備完了のとき、 **タイムスライス** 間隔でプロセッサの時間を使う

### 4.2.2. スレッドとブラウザ

### 4.2.3. スレッドを使うデータフロー計算

- 各スレッドはデータフロースレッド、データが使えるようになるまで待つことがある

#### 単純なデータフローでの振る舞い

#### 平行的状況で宣言的プログラムを使うこと

- 直列の場合と実行結果は同じ
- バッチ的実行

#### データフローとゴム紐

#### 安価な並行性とプログラム構造

- スレッドの使用: モジュール化を進めるなど、プログラム構造の改良に繋がる事が多い
    - ほとんどの大きなプログラムにはスレッド化による改良の余地がある
- あまり資源を使わないスレッド化が良い
- 直列はどんな安価なスレッドを用いた平行よりも安価
- 必要としない限りスレッド化は避けるべき
- 構造の改良に貢献するのであればどんどんスレッド化すべき

### 4.2.4. スレッドのスケジューリング

- スケジューラの責務とその方法

#### タイムスライス

- **ラウンドロビン方式**
    - やり方
        - 全ての準備完了スレッドをキューに入れる
        - 各ステップにおいて、キューから最初のスレッドを取り出して数ステップ実行させる
        - キューに戻す
    - プロセッサ時間が、各準備完了スレッドに公平に割り振られることが保証
    - スレッドをキューから取り出し、再度キューに戻すのはコストがかかる
        - キュー管理のオーバーヘッド
        - (?:できるだけスレッドは大きめに処理をくくった方が良い？)
    - 一度取り出したスレッドにできるだけ多くの計算ステップを実行させる
- **タイムスライス**, **クォンタム**
    - 各スレッドが持つ最大時間間隔
    - 超えない範囲で計算ステップを実行できる
- **横取り**
    - スレッドのタイムスライスが尽き、スケジューラがそのスレッドの実行を停めること
    - スレッドはキューに戻される
- 各スレッドがプロセッサ時間を同じ割合で使用するようにする方法
    - **計数法**
        - スレッドの計算ステップを数え、同数の単位時間を与える
        - 決定性である
        - タイミングの保証が重要なアプリに使用
    - **タイマ法**
        - ハードウェアタイマを使ってスレッドに同じ時間を与える
        - 効率がいい
        - 決定性でない: OS内の様々なイベントが影響を及ぼしうる

#### 優先順位レベル

- うまくスレッド間のプロセッサ時間分配を調整する必要がある
    - 緊急で処理すべきイベントが発生するかもしれない
- スレッドに **優先順位レベル** を与える

#### 優先順位の継承

- 新しく作成されたスレッドは、親と同じ優先順位が与えられる
- 子スレッドのレベルは親より低くてはならない
    - そのスレッドのレベルが引き上げられるまでに、何度もリスケされるコストが発生する恐れがあるため

#### タイムスライスの長さ

- 横取りをどう実装するか
    - 内部的
    - 外部的
        - こちらの方が実装しやすい
- 10ミリ秒のタイムスライスでも長すぎるアプリ
    - 多くのスレッドを持つ場合、スレッド同士は強く相互に依存している
    - どのスレッドも別のスレッドに譲るまで、タイムスライスを使い切らない
- タイムスライスが短すぎるアプリ
    - スレッドが他のスレッドと独立に外部と相互作用するもの(?:例)
    - 厳しいリアルタイムコンピューティングシステムが必要
    - 特殊なハードウェアとOSを要する

### 4.2.5. 協調的並行性と競合的並行性

- スレッド: 協調的並行性を意図したもの
- 協調的並行性
    - ある全体的な目的を目指してともに働く実体
    - スレッド: 全てが3つの優先順位レベルの間で時間の割合を変えることができる
    - 全ての部分が信頼しあって走るアプリのためのもの
- 競合的並行性
    - それぞれの目的を持ち、自分自身のために働く実体
    - 自身の性能にのみ興味があり、全体的な性能を鑑みない
    - OSがプロセスをもって管理する
- 計算の持つ2層構造

```
OS --- Process/App(競合的並行性: アプリごとに異なる目的を持つ)
        -- Threadの集合(協調的並行性: 相互に作用し、同一の目的のために協調的に実行される)
    -- Process/App
        -- Threadの集合
```

### 4.2.6. スレッド操作

---

## 4.3. ストリーム



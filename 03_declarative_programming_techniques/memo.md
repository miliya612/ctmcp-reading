## 3. 宣言的プログラミング技法

- 操作が宣言的であるということ
    - **独立**
        - 外の実行状況に依存しない
    - **状態なし**
        - 複数の呼び出しの間に共有される内部実行状態がない
    - **決定性**
        - 同じ引数を与えられれば常に同じ値を返す

**宣言的プログラミングはなぜ重要か**

- 宣言的プログラミングの重要な性質
    - 合成的である
        - componentから構成されている
        - 単一componentは他のcomponentや実行状態に依存しない
        - 単一で書ける、テストできる、証明できる
    - 推論が簡単
        - 値(結果)についてのみ計算する
        - 単純な台数的・論理的推論技術を適用できる
- 宣言的モデルに適したプログラミングとそうでないものがある
- component
    - > きちんと定義された入力と出力を持つ、正確に範囲が定められたプログラム片
    - componentはより大きなcomponentを構成する
    - 手続きは一種のcomponent
    - component間の相互作用は、componentの入出力に定義される
    - 他を考えることなく理解できる
    - できるだけ宣言的にcomponentを書くべき

**宣言的プログラムを書くこと**

- 宣言的モデルを使うことで実現できる
- **参照透過性**
    - > 等しいものは等しいもので置き換えることができる(代数学の標準規則)
    - 引数だけに依存し、その他の計算状態に依存しない
- 基本的技法
    - 高階プログラミングを使ってプログラム構造を単純化する
    - プログラムを再帰的関数定義の集合とみなす
    - 直接再帰: 関数の本体の中で自身を参照するもの
    - 間接再帰: 関数の中で参照した関数が、初めの関数を最終的に参照するもの
    - 高階プログラミング
        - 関数の引数や結果が関数でよいこと
        - 抽象を構成するためのすべての技法の基本となる
        - 宣言的モデルの表現力の乏しさを補う
        - 制限された形の並行性と状態がコード化しやすくなる

### 3.1 宣言的とはどういうことか

#### 3.1.1 宣言的プログラムの分類

- 宣言的である: プログラムに関する推論が簡単になる
- > 「どのように」を説明せずに、「何」を定義する
- 達成したい結果を定義し、そのための必要なアルゴリズムなどは定義しない

**宣言的プログラミングの分類**

- 第１レベル
    - 記述的宣言性
        - 最も表現性に乏しい
        - データ構造を定義する
            - レコードを定義する文
            - eg. `skip`, `local <x> in <s> end` ...
            - htmlやxmlも
        - 処理しやすいデータ構造を実現する
    - プログラム可能な宣言性
        - チューリングマシンと同等の表現性を持つ
        - 2つの見方
            - **定義的見方**
                - 宣言性をコンポーネント実装の性質とみる
                - 宣言的モデルで書いてあればプログラムは宣言的である
            - **観察的見方**
                - 宣言性をcomponent I/Fの性質とみる
                - 実装が宣言的モデルで書かれていなくても、宣言的に振る舞えばok
        - 定義的宣言的プログラミングの2つのスタイル
            - 関数型プログラミング
                - 数学的関数として定義
                - Haskell, Standard ML
            - 論理型プログラミング
                - 論理的関係として定義
                - Prolog, Mercury

#### 3.1.2 使用記述言語

- 宣言的プログラムは仕様が全てと思われがち
    - 仕様: I/F定義が全て
- アルゴリズム、データ構造、構造化、操作順序に関する推論が必要
    - 効率的に実装される数学しか使えないため
- 実際は、仕様よりもプログラム自体の方が長い
    - 表現性と効率の間のトレードオフのため(表現性を犠牲にしている)
- **仕様記述言語**
    - 宣言的言語の表現性を拡張して定義した言語
    - 効率的に実装するのは通常困難
    - プログラムを考えるための重要なツール
    - **定理証明器**と一緒に使える(?)

#### 3.1.1 宣言的モデルにおいてコンポーネントを実装すること

- 定義的見方の証明をする
- 文が定義的であること
    - 宣言的モデルの文が与えられる
    - 文の中の自由識別子を入力と出力に分ける
    - 入力識別子に部分値が束縛される
    - 束縛されていない変数が出力識別子に束縛される
    - 文を実行する
    - 結果を得る
        - 出力変数に対する何らかの束縛
        - 待機
        - 例外
    - 文自体が宣言的であれば、同じ入力に関する出力は不変

- 推論
    - 宣言的モデルのすべての基本操作は宣言的
    - 宣言的操作を宣言的モデルの要素と組み合わせると、宣言的操作になる
        - 文の列
        - `local`文
        - `if`文
        - `case`文
        - 手続き定義: `<x>=<y>`(手続き値)
- 決定性な文で構成された文は決定性となる

### 3.2 反復計算

- 宣言的モデルの中でどうプログラムするか
- 例: 反復計算
    - ループ
    - スタックの大きさは一定を超えない

#### 3.2.1 一般的図式

- 初期状態`S0`から出発し、皇族ステップの状態を更新して`Sfinal`となる

```
fun {Iterate Si}
    if {IsDone Si} then Si
    else Si+1 in
        Si+1={Transform Si}
        {Iterate Si+1}
    end
end
```

- 意味スタックの変化
    - 0. `[R={Iterate S0}]`
    - 1. `IsDone`がfalseの場合、`[S1={Transform S0}, R={Iterate S1}]`
    - 2. `Transform`を実行し、`[R={Iterate S1}]`
    - 常に意味スタックには１つしか残らない
        - cf. 末尾呼び出し最適化

#### 3.2.2 数についての反復

- ニュートン法の例

#### 3.2.3 局所的手続きを使うこと

- 局所的手続き: 補助的関数、補助的ルーチン
    - 定義を助けるためのルーチン
    - 他所から見えるべきでない
- 補助関数とUtility関数(他所でも使われうる関数)をどう定義するか
    - **可視性**を表現する

a. そのまま書く

```
fun {Main X}
    ...
in
    {Helper X}
    ...
end
fun {Helper X}
    {UtilHoge X}
    {UtilFuga X}
    ...
end
fun {UtilHoge X}
    ...
end
fun {UtilFuga X}
    ...
end
```

b. 補助ルーチンをMainの外の`local`文の中で定義

```
local
    fun {UtilHoge X}
        ...
    end
    fun {UtilFuga X}
        ...
    end
    fun {Helper X}
        {UtilHoge X}
        {UtilFuga X}
        ...
    end
in
    fun {Main X}
        ...
    in
        {Helper X}
    end
end
```

c. 補助ルーチンを必要とするルーチンの中で定義

```
fun {Main X}
    fun {Helper X}
        fun {UtilHoge X}
            ...
        end
        fun {UtilFuga X}
            ...
        end
    in
        {UtilHoge X}
        {UtilFuga X}
        ...
    end
in
    {Helper X}
end
```

- bは可視性を犠牲にしている
    - Util関数をHelper関数だけに局所的にすることも可能
    - `local`が入れ子になり読みづらい
- cのHelper関数、Util関数の引数Xを自由識別子ともできる

d. cの変数定義を改善

```
fun {Main X}
    fun {Helper}
        fun {UtilHoge}
            ...
        end
        fun {UtilFuga}
            ...
        end
    in
        {UtilHoge}
        {UtilFuga}
        ...
    end
in
    {Helper}
end
```

- 補助ルーチンの定義を、必要とするルーチンの中に入れるかどうか
    - 中に入れる(c, d)
        - lexical scopeによってMainルーチンの引数を外部参照できる
            - 補助ルーチンの引数が少なくても済む
        - Mainルーチンが呼ばれるたびに補助ルーチンが新たに生成される
            - 新たな手続き値が生成される
    - 外に出す(a, b)
        - Mainルーチンが何度呼ばれようと、手続き値は１回しか生成されない
        - 補助ルーチンの引数は増える
    - 生成回数が多い(反復のたびに生成される)ものは外に出し、そうでないものは局所的にするとバランスがとれる

#### 3.2.4 一般図式から制御抽象へ

- 一般図式
    - プログラマが効率的なプログラムを設計するのを助ける
- **制御抽象**
    - 計算モデルからみたもの
    - 他のcomponentで使えるcomponentとしての一般的図式
    - 望ましい制御フローを用意するのに使える抽象
- 制御抽象にする
    - ユーザー(呼び出し元)によって異なる部分を抽出して引数化する

a. 一般図式

```
fun {Iterate Si}
    if {IsDone Si} then Si
    else Si+1 in
        Si+1 = {Transform Si}
        {Iterate Si+1}
    end
end
```

b. 制御抽象化したもの

```
fun {Iterate S IsDone Transform}
    if {IsDone S} then S
    else S1 in
        S1={Transform S}
        {Iterate S1 IsDone Transform}
    end
end
```

c. 使い方

```
fun {Sqrt X}
    {Iterate
        1.0
        fun {$ G} {Abs X-G*G} / X < 0.00001 end
        fun {$ G} (G+X/G)/2.0 end}
end
```

- 一般的な制御フロー(反復)を具象的な使い方から分離している
- 高階プログラミングを活用している


### 3.3 再帰計算

- 反復計算は再帰計算の具象ケース
- 反復計算
    - あるアクションが何回か繰り返されるループ
    - `Iterate`関数を導入して実装した
    - あたえられた条件をテストし、偽であればアクションを行い、自分を呼び出す
- 再帰計算
    - 本体のどこでも、複数回自身を呼び出せる
    - プログラムの中で使われるケース
        - 関数の中
            - 定義の中に自分自身への呼び出しが少なくとも１つある場合
        - データ型の中
            - 自身に基づいて定義している場合
            - eg. リスト: 自身より小さいリストに基づいて定義されている
        - 再帰的データ型の処理に再帰的関数が使える
- 反復計算はスタックの大きさが一定である
    - 末尾呼び出し最適化のおかげ
- 再帰計算の場合、一般的に当てはまらない
    - eg. 木について計算する場合
- 宣言的プログラミングにおいて、スタックの拡大を避けるのが重要
    - どうやって？を示す

階乗関数の素朴な定義(典型的な再帰計算、反復的でない)

```
(数学的)
0! = 1
n! = n * (n-1)! if n > 0

-> n=0, n>0の可能性がある

(プログラム)
fun {Fact N}
    if N==0 then 1
    elseif N>0 then N*{Fact N-1}
    else raise domainError end
    end
end
```

- 大きな数の階乗をより小さな数の階乗を使って定義
- 階乗は **部分関数**
    - 負のNに対して定義していない
    - 例外を発生させることで示す

#### 3.3.1 スタックの大きさの増加

- スタックの大きさの最大値は、引数`N`に比例する
- 核言語の意味を利用して示す

```
(核言語)
proc {Fact N ?R}
    if N==0 then R=1
    elseif N>0 then N1 R1 in
        N1=N-1
        {Fact N1 R1}
        R=N*R1 %再帰呼出しのあとに掛け算がある！
    elseif raise domainError end
    end
end
```

- スタックは拡大しそう
    - 再帰呼び出しの間、スタックに掛け算の情報を保持する必要があるため
    - 再帰呼び出しのあとに掛け算があるため

#### 3.3.2 代入ベースの抽象マシン

- 2章の抽象マシンは、現実的なコンピュータの上での実装を示しているが手計算には面倒
    - 変数識別子と格納域変数の両方を持つ
    - 環境を使って一方を他方に写像する
- **代入** の操作を追加する
    - 意味表明中の識別子を、参照する格納域実体に置き換える
    - 環境がない
        - 識別子に格納域実体を直接代入するため

- 抽象マシン
    - 環境ベース抽象マシン
        - 現実のコンピュータの実装に忠実
        - 環境を備えている
        - 間接的に識別子が格納域実体を参照するため、手計算が困難
    - 代入ベース抽象マシン
        - 手計算が楽、扱う記号が少ない
        - 実装が面倒で、現実の実装には採用されない

#### 3.3.3 再帰計算を反復計算に変換すること

### 3.4 再帰を用いるプログラミング

- 再帰的データ型を定義
- リストに対する基本的プログラミング技法を示す
- 反復計算を定義し、宣言的プログラムを効率的にする
    - **アキュムレータ**
- **差分リスト**を示す
    - 計算を反復的に保ちながら、データ構造を漸増的に構築する効率的な技法
- キューの効率的な実装、償却的効率
- 木の技法
- ケーススタディ

#### 3.4.1 型の記法

- 再帰的なデータ型
    - リスト
        - `nil` or `X|Xr` (Xr: リスト)
- 文脈自由文法記法を基に記述
- 手続きの型: **シグニチャ**
    - 主要情報を簡潔に伝えるため
- 表現力の限界
    - 正整数は定義できない
        - 0以上の正の整数の集合
    - 部分値の集合、差分リストなどを定義できない
    - ある変数が取る値の集合についての **論理的表明** を与える
    - コンパイラでチェック困難

#### 3.4.2 リストについてのプログラミング

基本的技法

- 再帰的に考える
    - 問題を小さくして考える
- 再帰計算を反復計算に変換する
    - スタックの大きさの無駄を省く
    - **状態変換** を使う
- 反復計算の正しさ
    - **状態不変表明** を使用して、推論を行う
- 型をなぞってプログラムを構築する

##### 3.4.2.1 再帰的に考える

- 自分自身のより小さい形を基に定義される
- リスト処理: 再帰的構造をなぞる
    - 基本: 小さなリスト(empty or 0, 1,2)について直接値を計算する
    - 再帰: 要素が１つ以上少ないリストの結果に基づいて計算する

##### 3.4.2.2 再帰的関数とその定義域

- 定義域に属さない値が関数に与えられたら、例外を発生させるべき
- 同型の範囲に属していないのならば`if`文で書ける
- 型のアサーションは静的型付けでないと難しい

##### 3.4.2.3 素朴な定義は遅いことが多い

- 遅い
    - 実行時間が長い、Orderが大きい
- 再帰的に計算をしている
    - 効率が悪い

- 回避する技法(線形時間であるO(n))
    - 状態変換
    - 差分リスト

##### 3.4.2.4 再帰計算を反復計算に変換すること

- スタックの大きさを一定にしたい
    - 問題を状態変換の列に作り直す
    - 反復: S0から始まり、S1, S2,...に変形され、答えを含むSfinalに至る
    - 状態として何を持つべきかを考える

##### 3.4.2.5 状態不変表明による正しさ

- 状態の性質が常に真であることを証明するP(Si)を定義する
- 状態不変表明P(Si)を定義する
- 計算の正しさはP(Sfinal)に従う
- Pの選び方が難所
    - 計算が進行しても結果が変化しないようにする
    - 計算全体の正しさがP(Sfinal)から従う、といえるほど強い

##### 3.4.2.6 型をなぞってプログラムを構成すること

- リスト関数は、リストの型定義と同形の再帰構造を持つ
- NestedListの例
- 型の定義次第で、それを扱う関数の書き方が大幅に簡単になる
- 教訓
    - ある型を使う再帰的関数を書く前に、その型の再帰的定義を書かなければならない
    - 誤った関数にだまされる恐れがある
    - 再帰的な型の設計はプログラマの責任

##### 3.4.2.7 マージソート

- **分割統治** の戦略を取る
    - リストを、ほぼ等しい長さの２つの小リストに分割する
    - マージソートを再帰的に使い、２つの小リストをソートする
    - ソートされた２つの小リストをマージし、最終結果を得る
- 効率的、分割もマージも線形時間の反復操作であるから

##### 3.4.3 アキュムレータ

- 最初から反復的に書く方法
    - 常に状態を先送りし、決して戻ってきてから計算しないこと
    - 状態`s`は、それ自身に **アキュムレータ**を加えることで表現される
        - アキュムレータ: 入力引数 `S1`と出力引数 `Sn`の対のこと
- 状態のスレッド化
    - 各手続きの出力が次の手続きの入力になること
    - **アキュムレータプログラミング**: 入れ子の手続き呼び出しを通じて状態をスレッド化する技法

**複数アキュムレータ**

- 複雑なプログラムには多くのアキュムレータを必要とする
- 明示的状態を使うプログラミングでは、アキュムレータを少ししか使わないはず
- 数が増えてきたらもっと上手く書き直せる証

- アキュムレータを使うマージソート: Splitを書きなせる、メモリ使用量が減る

#### 3.4.4 差分リスト

- 2つのリストの対
- どちらのリストにも束縛されていない尾部があるかもしれないもの
- eg. `(a|b|c|d|X)#X %=>[a,b,c,d]`

- 差分構造の具体例
    - 2つの部分値の対で、2番目の値が最初の値に埋め込まれているもの
    - 値: 第1の値から第2の値を引き去ったもの
    - 再帰的データ型について反復計算を構成するのが容易になる
- 差分構造はアキュムレータの具体例
    - アキュムレータの1つの引数が束縛されていない変数でもいいようなケース

- 利点: 定数時間でリストを連結できる(場合がある)
    - 第2のリストが未束縛であった場合、それに新たなリストを束縛するだけで連結できる
- 限界: 一度しか連結できない
- Prologと論理型プログラミングから始まった
- 概念
    - 値という概念と状態という概念の間に位置する
        - 値の美質: 値を使うプログラムは宣言的である
        - 状態の力: 一定時間で一度だけ連結することができる

## 3.7

- wrapper
  - 保護するのは、内部に持つリストや木構造？
  - 見た感じ、リストの中の要素を保護しているような
  - ちゃんと内部のリストを保護してた(3.32)

- ストリーム、という言葉が出てきた
  - RxJavaなどのfrpは、pub/subと呼ばれるが、内部ではデータフロー実行を行っているのだろう
- 新しい名前生成
  - 一意性
    - ハッシュ関数もこの話
      - あえてdictionaryのところで触れなかったのは、この本の序章であった通り、アルゴリズムやデータ構造をメインとしていないからだろう
    - UUIDもこの話

### 3.7 資格とセキュリティ

- jvm言語を選ぶモチベーション？
- 最少権利の原則
- id, 認証, token


### 3.8 宣言的でない必要物


* モジュール=class?
  * rubyで言うclassなのかmoduleなのか
  * 宣言的でないもののみをモジュールと呼ぶ？
* 実世界とは何か
  * 我々が生きている現実世界
  * プログラムが生きるOSに管理された世界
* 文字コードの列とアトム
  * アトムの場合、改行も反映される言語がおおい
  * 仮想文字列: rubyの式展開？
* webサーバーは普通読み込みしか許さない
  * appサーバーの前段にwebサーバーを置くのって、結構想定されてない動作なのだろうか


### 3.9小規模プログラム設計

* プログラムの大小
  * 関わった人数
  * チーム構成による
* 例: TDD?
* 推論、実際の開発ではどんなドキュメントを残す？
* モジュール仕様、ファンクタ: constructor?
* component based programming: 目指す世界はmicro serviveと一緒
* 高階プログラミング技法とcomponent based programmingの違い
  * 高階: 振る舞いを外部から与える
  * component: 振る舞いは内部で定まっている、分離？イマイチ……


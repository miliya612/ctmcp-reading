# 2 宣言的計算モデル

## introduction

- プログラミングの３つの要素
    - 計算モデル
        - formal system, 形式的体系
        - １つの言語を定義
            - 命令が抽象マシンによってどのように実行されるのか
    - プログラミングモデル
        - プログラミング技法と設計原則の集合
        - 計算モデルの上に構築される
        - 特定の計算モデルに基づいた言語でどのようにプログラムを書くか
    - 推論技法の集合
        - プログラムが正しく振る舞うという確信を深める
        - プログラムの効率を算定する
- 計算モデルの定義
    - 一般的
        - > 命令が抽象マシンによってどのように実行されるのか
    - 妥当、プログラマにとって有益
        - 多くの問題を解くのに使える
        - 明快かつ実用的な推論技法を持つ
        - 効率よく実装できる
- **宣言的プログラミングモデル**\(declarative programming\)
    - 部分的データ構造\(partial data structure\)の上で関数を計算すること
    - 状態なしプログラミング\(stateless programming\)
        - cf. 状態ありプログラミング\(stateful progrmming\)
- **宣言的計算モデル**
    - 最も基本的な計算モデル
    - 主要な宣言的パラダイムの中核的な考えを含む
        - 関数型プログラミング
            - 完全値(complete value)について計算する
        - 論理型プログラミング
            - 決定性を持つ
            - 探索を行わない場合のProlog?
    - 並行的な処理も可能
    - より表現力豊かな計算モデルの概念のほとんどを見て取ることができる

## agenda

1. 実用的プログラミング言語のsyntaxとsemanticsの定義方法

## 2.1. 実用的プログラミング言語の定義

宣言的計算モデルを提示する基礎となる

### 2.1.1 言語の構文(syntax)

- 上手く実行できるプログラムとは何か

#### grammer

- 単語から文を作り上げる規則の集合
    - 単語 == `token`

```
文 = tokenの列
token = 文字の列
```

- 入力のgrammer的解釈の順序
    1. 文字の列をtokenの列に変換
        - **字句解析プログラム**(tokenizer, lexical analyzer)
    2. tokenの列を**構文木(parse tree)** に変換
        - **parser**(構文解析プログラム)

#### EBNF

- Extended Backus-Naur Form
- **終端記号(terminal symbol)**
    - token
- **非終端記号(nonterminal symbol)**
    - tokenの集合
    - どのようなtokenの列に展開されるのかを示す規則

```
<digit> ::= 0|1|2|3|4|5|6|7|8|9
<int> ::= <digit>{<digit>}
```

#### 文法をどう読むか？

- 任意の非終端記号から出発し、左から右に読み進める
    1. 出会った終端記号を列に追加する
    2. 非終端記号に出会った場合、文法規則に応じて展開し、得られた終端記号の列で非終端記号を置き換える
    3. いくつかの選択肢がある場合、適当なものを選択する
- 文法の用途
    - 合法的であるかを検証する
    - 文を生成する

---

#### 文脈自由文法と文脈依存文法

- **形式的言語** (formal language)
    - とある文法に基づいて明確に定義された文の集合
    - 文法を定義する技法: 技法が持つ **表現力** によって分類
        - どういう種類の言語を生成しうるか
        - EBNF(技法): **文脈自由文法(context-free grammer)** といった文法クラス、言語を生成する
        - 文脈自由: 非終端記号がどこに置かれようと、同じように展開される
- ２種類の言語構文の定義
    - **文脈自由文法(context-free grammer)**
        - 理解しやすい
        - 局所性、規則だけをみれば解釈可能
    - **文脈依存文法(context-sensitive grammer)** 
        - 文脈自由文法のみで合法的なプログラミング言語を定義することは困難
            - eg. 変数には事前定義が必要
        - 言語特有の制約を課すことで定義を補う

#### あいまいさ

- 文脈自由文法はあいまいさ(ambiguous)を伴う
    - eg. `2*3+4=?` `2-3-4=?`
- 追加の条件が必要
    - **優先順位**(precedence)
        - 演算子ごとに優先順位を与える
        - 優先順位が高い演算子は、構文木の深い位置におく
    - **結合性**(associativity)
        - 左右の演算子のどちらが緊密に結合するか

#### この本で使う構文記法

### 2.1.2 言語のsemantics

- あるプログラムの実行が何をするかを定義
- 理想
    - 単純な数学的構造によって定義
    - プログラムの推論を可能にする
        - 正しさ
        - 実行時間
        - メモリ使用量
        - ...
    - ->核言語によって実現
- 現代のプログラミング言語の振る舞いを、根底にある単純なモデルによって説明したい

#### 核言語手法

- プログラミング言語のsemanticsを定義するための手法
- 言語のすべての構成要素を核言語への翻訳を通して定義する
- 構成
    - 核言語を定義する
        - 単純である
        - 正しさや実行時間などが推論可能である
        - 空間効率や時間効率を反映する
        - *核言語とそれを操作するデータ構造が合わさって核言語モデルを作る*
    - 核言語へと翻訳する方法を定義する
        - 簡単である
        - 種類
            - **言語抽象** (linguistic abstraction)
            - **糖衣構文** (syntactic sugar)
- 宣言的核言語

#### 形式的意味

- 核言語のsemanticsを定義する方法
    - **操作的意味**
        - 抽象マシンにおいてどのように実行されるか
    - 公理的意味
        - 入力状態と出力状態の関係から定義
        - 論理的表明によって定義
        - 状態ありモデルに適している
    - 表示的意味
        - 抽象的定義域における関数として定義
        - 宣言的モデルに適している
        - 平行言語には適用が難しい
    - 論理的意味
        - 論理的理論のモデルとして定義
- 操作的意味を用いてformal semanticsを示す

#### 言語抽象

- ある言語への新しい要素の追加: **言語抽象**
    - 処理群の抽象
    - 言語の構文への追加
- 段階
    1. 新しい文法要素を定義する
        - 関数定義
        - 呼び出し方
    2. 新しい文法要素を核言語に翻訳する方法を定義する
        - 引数がどのように実行されるか？
        - 関数呼び出しの順序は？など
- 有用性
    - プログラムの表現性を高める
    - 正しさを高める
    - セキュリティを高める
    - 効率を高める
    - プログラマの誤用を防ぐ

#### 糖衣構文

- 目的
    - よく使用する慣用句に略記法を設けること
- 内容
    - 元の言語に翻訳されることで、semanticsが定義される
    - 新しい抽象を用意しない
    - Programの大きさを減らし、読みやすさを向上させる
        - 言語抽象との違い

#### 言語設計

- 言語抽象を基本ツールとして行う
- 言語における抽象化のライフサイクル
    1. 言語に構文が存在しない段階
    2. 言語的支援が与えられる段階
        - 基本的で有用だと認められた状態
        - 言語抽象はこの段階
    3. 言語の一部となる段階
        - プログラムの単純化に貢献すると認められた状態
        - プログラマにとって有益だと認められた状態

#### その他の翻訳手法

- semanticsに対する翻訳手法の種類
    - 核言語手法
        - ある言語から他の言語への翻訳をベースとする
        - プログラマが推論し、理解するのを助ける
    - 基礎論的計算手法
        - チューリングマシン、ラムダ計算など
        - 数学的研究向け
    - 抽象マシン手法
        - 抽象マシン、仮想マシンのマシンコードに翻訳する
        - 実装者向け

#### インタプリタ手法

- what
    - 翻訳手法と並ぶもの
    - 言語のインタプリタを作成することで、semanticsを定義する
    - 新しい言語 = インタプリタの拡張
- pros
    - 言語抽象を自己の内部で実装する
- cons
    - プログラムの実行時間計算量を正しく反映しないことが多い
        - 入力の大きさの関数としての必要命令数
    - インタプリタの中で基本概念が相互に干渉することがある

## 2.2 単一代入格納域

- 宣言的モデルの導入を始める
- データ構造の説明
- **単一代入格納域** (single-assignment store)
    - 初めは何も束縛されていない
    - 後に1つの値としか束縛できない変数の集合(再代入不可)

### 2.2.1 宣言的変数 (declarative variable)

- 単一代入格納域の中の変数
- `データフロー変数 (dataflow variable)` とも呼ばれる
    - データフロー実行における役割を鑑みる
- いったん束縛されると、以降束縛されたままとなる( **再代入不可** )
- 値と区別されない

### 2.2.2 値格納域 (value store)

- すべての変数が値に束縛されている格納域
    - == 変数から値への恒久的写像
    - 値に束縛されていない変数は存在しない
- 値
    - 数学的定数(整数など)
    - 複合実体(リスト)
        - 1つ以上の値を含む実体
- 関数型言語は値の上の関数を計算するだけ -> 値格納領域で間に合う
- Smalltalk, C++, Javaは束縛された内容が変更可能 -> `セル格納域` が必要

- 値格納域、セル格納域に加えて単一代入格納域を導入した理由
    - **部分値** について計算したいから
        - eg. 引数になっている未束縛の変数に値を束縛して返す
    - 宣言的並行性
        - ref. 4章
    - 関係/論理プログラミング、制約プログラミングの要請

### 2.2.3 値生成

- 格納域上の基本操作
    - 変数に新しい値を束縛する
    - `Xi = value`
    - Xi: 格納域中の変数を直接指す
        - 変数の識別子ではない
- 手順
    - 格納域中に`value`を構築
    - `value`を変数に束縛
    - 変数が既に束縛されていた場合、それが`value`と両立する(`compatible`)かどうか調べる
    - 両立しなければエラーが合図される

### 2.2.4 変数識別子

- **格納域実体**
    - 変数と値
    - 計算可能
- **変数識別子**
    - 格納域の外から格納域実体を参照するための役割
    - 変数識別子から格納域実体への写像: **環境**(environment)
    - ソースコード中の変数名

```
任意の識別子: <x>
格納域の変数: Xi
環境: {<x> -> Xi}
```

### 2.2.5 識別子を使う値生成

- 識別子`X`に配列`[1, 2, 3]`が束縛されていること
    - `"X" -> Xi -> (1, ) -> (2, ) -> (3, nil)`
- **参照剥がし** (dereference)
    - 束縛された変数のリンクを辿って値を得ること

### 2.2.6 部分値

- 束縛されていない変数を含んでいるかもしれないデータ構造

```
Person{
    name: "George",
    age: X2, # 束縛されていない変数X2
}
```

- **完全値**
    - 束縛されていない変数のない部分値

```
Person{
    name: "George",
    age: 25,
}
```

- 宣言された変数にはいくつかの部分値を束縛できる
    - 同一パラメータに既に異なる値が束縛されている場合は不可

### 2.2.7 変数の、変数への束縛

- 変数に変数を束縛できる
- 相互に相手を参照した格納域の実体{X1, X2}: **同値集合**(equivalence set)
- 同値集合のどれか１つの変数が束縛されると、その他の変数もその値に束縛される

```
識別子"X": X1
識別子"Y": X2
X=Y -> X1 == X2 #{X1, X2}: 同値集合
```

### 2.2.8 データフロー変数

- 宣言的モデル
    - 変数の生成と束縛は別々に行う
    - **変数使用エラー(variable use error)**: 束縛前に変数を利用する
- 関数型プログラミング言語
    - 変数の生成と束縛を同時に行う
- その他
    - 変数と束縛を別々に行うことができる
    - variable use errorがあったときの挙動(悪い順)
        1. C++: 実行を継続し、エラーなし。変数は定義されず、メモリにゴミが生まれる。
            - 実行するたびに結果が異なる
            - エラーに気づかない
        2. Java(object, array): 実行を継続し、エラーなし。変数は宣言時にデフォルト値で初期化される。
            - 結果は変わらない
            - エラーに気づかない
        3. Prolog: 実行中止、エラー表示。
            - 平行プログラミングの場合、非決定性な結果になる
        4. Java(local var): コンパイラが未初期化変数を検知し、実行させない。
            - まだマシ
        5. Oz: 変数が束縛されるまで待ち、実行。dataflow programmingをサポート。
            - 直列システムの場合、永遠に待ち続けることになる
            - 平行システムの場合、別スレッドの束縛を待つのはあってよい動作
            - typoなどにより無限に待機(suspension)する可能性がある(デバッガで検知されるべき)

- **データフロー変数(dataflow variable)**
    - 束縛されるまでプログラムを待たせるような宣言的変数
    - 平行プログラミングに有効
    - **順序無関係性**

## 2.3 核言語

- 核言語のsyntaxとsemanticsの定義
- 宣言的言語全体をどのように核言語の上に構築する方法

### 2.3.1 構文

- 親言語においても正しい文となる

#### 文(statment)の構文`<s>`

```
&lt;s&gt; ::=
    skip                                                空文
    | &lt;s&gt;1 &lt;s&gt;2                                         文の列(直列合成)
    | local <x> in &lt;s&gt; end                              変数生成(local文)
    | <x>1=<x>2                                         変数の、変数への束縛
    | <x>=<v>                                           値生成
    | if <x> then &lt;s&gt;1 else &lt;s&gt;2 end                    条件式(if文)
    | case <x> of <pattern> then &lt;s&gt;1 else &lt;s&gt;2 end     パターンマッチング(case文)
    | {<x><y>1....<y>n}                                 手続き適用(手続き呼び出し)
```

#### 値(value)の構文`<v>`

- 数、レコード、手続きを表す３つの値表現
- `<x>1...<x>n`はそれぞれ全て異なるものでなければならない
    - 変数の、変数への束縛を明示的な操作として記述するため

```
<v>                 ::= <number> | <record> | <procedure>
<number>            ::= <int> | <float>
<record>, <pattern> ::= <literal>
                        | <literal>(<feature>1: <x>1...<feature>n: <x>n)
<procedure>         ::= proc{ $<x>1...<x>n} &lt;s&gt; end
<literal>           ::= <atom> | <bool>
<feature>           ::= <atom> | <bool> | <int>
<bool>              ::= true | false
```

#### 変数識別子の構文<x><y>

- 変数識別子を表すのに、非終端記号`<x>`, `<y>`を使う
    - `<z>`も使用する
- 書き方
    - 英大文字のあとに0個以上の英数字orUnderScore
        - eg. `X` `X1` `ThisIsALongVariable_IsntIt`
    - 任意の印字可能文字を`\``で囲んだもの
        - eg. `this is a 25$\variable!`
- きまり
    - 全ての変数は宣言時に束縛されていない
    - 全ての変数は明示的に宣言されなければならない

### 2.3.2 値と型

- **型**, **データ型**
    - 値、及びそれの操作の集合
- 宣言的モデル
    - きちんと定義された基本型(basic type)の集合を持つ
    - 型の使い方はシステムがすべて確認する
        - ある操作を不正な型に適用するとエラーが発生する
        - 0での除算など、エラーは発生しうる
    - エラーが発生するとただちに処理は停止する、処理する機構はない
    - **Exception**を用いて後ほど拡張する
    - 独自型(**抽象データ型**, **ADT - Abstract Data Type**)の定義もできる

#### 基本型

- 数
    - 整数
    - 浮動小数点数
- レコード
    - atom
    - boolean
    - touple
    - list
    - string
- 手続き(procedure)
- chunk
- fanctor
- cell
- dictionary
- array
- port
- class
- object

#### 動的型付け

- 型の付与方法
    - **動的型付け**
        - 変数が束縛されるときに型がわかる
        - 宣言的モデル
        - コンパイラが操作対象の型が正しいことを確かめようとするが、一部は実行時に確かめられる
    - **静的型付け**
        - コンパイル時に全ての変数の型がわかる

#### 型の階層

- 基本型を階層的に分類可能である
- 集合の包括順序に従って順序付けられる

```
-- value
    -- Number
        -- Int
            -- Char
        -- Float
    -- Record
        -- Literal
            -- Bool
                -- True
                -- False
            -- Atom
            -- ...
        -- List
            -- String
        -- ...
    -- Procedure
        -- ...
    -- ...
```

### 2.3.3 基本型

- 数
    - 整数か浮動小数点数
    - 負号: `~`(チルダ)
        - eg. `~10`(マイナス10)
- atom
    - 記号的定数
    - 計算における単一要素
        - eg. `a_person`, `'#### hello ####'`
- bool
    - `true` or `false`
- record
    - 複合データ型
    - ラベルの後に、フィールド名と変数識別子の対の集合を続けたもの
        - フィールド名: atom, 整数、bool
    - eg. 
        - `person(age:X1 name:X2)`
        - `person(1:X1 2:X2)`
        - `'|'(1:H 2:T)`
        - `nil`
        - `person`
    - atomはフィールドのないrecord
- touple
    - record, フィールドが1から始まる連続整数
    - フィールド名は省略可能
    - eg. `person(1:X1 2:X2)` `person(X1 X2)`
- List

### 2.3.4 レコードと手続き

- なぜ核言語においてレコードと手続きを基本概念にしたのか

#### レコードの威力

- レコードはデータを構造化する基本的方法であるため
    - データ構造の基本要素
- レコードが言語に支援されていると、その他の技法の有効性を高めることができるため
    - オブジェクト指向プログラミング
        - レコードでオブジェクトが通信に使うメッセージとメソッドヘッドを表現する
    - GUI
        - 基本要素となるWidgetを表現する
    - コンポーネントベースプログラミング
        - 関連する操作をひとまとめにする第一級モジュール(first-class module)を表現する

- レコードの支援がある言語: **記号的言語**(symbolic langage)
- 宣言モデルにおける支援
    - 容易に生成できる
        - 完結な構文で書き下すだけ
    - 容易に分解できる
        - パターンを書き下すだけ
    - 容易に操作できる
        - フィールド追加
        - フィールド削除
        - フィールド選択
        - リストへの変換
        - リストからの変換

#### なぜ手続きか？

- オブジェクトをなぜ入れない？
    - 単純に保ちたかったから
- 関数になぜしない？
    - 必ずしも数学的関数のように振る舞う実体を定義しないため
    - 入力と出力の個数に柔軟性をもたせるため
        - 関数は常に１つの値を吐き出す

## 2.4 核言語のsemantics

- 核言語の実行: 部分値の上で関数を計算
- 計算モデルを使って核言語の意味を与える
    - プログラムの正しさと計算量を簡単な方法で推論できるように設計

### 2.4.1 基本概念

#### 変数識別子と静的スコープ
    
- `local`文
    - 新しい変数の生成
    - 識別子の参照を変数に向ける
    - `end`までの間のみで通用する **スコープ**が生まれる
- **字句的スコープ(レキシカルスコープ)**
    - テキストを眺めるだけで判別できるスコープ
    - eg. `local`と`end`の間

#### 手続き
    
- あらゆる言語における基本要素
- どのようにして手続きを定義し、呼び出すかを示す
- **参照呼び出し**
    - 束縛されていない変数の参照を渡された手続きが、その変数を束縛して処理を終えるような呼び出し方
    - データフロー変数や**値可変変数** に利用される

#### 外部参照のある手続き

- **自由識別子**
    - 手続きの本体の中で定義されていない変数
    - 手続きの枠の中に入れることで、引数として識別子が宣言されているため実行可能となる
    - 引数としても定義されていない変数があっても、手続きの定義箇所における静的スコープ内で定義されていれば、それを参照する
    - **実行時ではなく、定義時のスコープを参照して手続きが実行される**

#### 手続きスコープ対静的スコープ

- 静的スコープ
    - プログラム定義時に、該当ブロックを取り囲む最も内側で定義された変数を参照する
- 動的スコープ
    - プログラム実行時に、実行箇所から最も間近に宣言された定義を用いて変数を参照する

#### 手続き抽象

- 概念
    - **手続き抽象**
        - どんな文も手続き宣言の中に置くことで、それらを手続きという形に抽象化することができる
    - **自由識別子**
        - 文の中で定義されていない識別子のこと。文を取り囲む文の中で定義されている
    - **静的スコープ**
        - 手続きの中に存在する外部参照の値は、その手続が定義されたときに持っていた値である、というスコープ定義の方法。

#### データフロー的振る舞い
    
- **データフロー的振る舞い**
    - 手続きの中に未束縛な変数があった場合、プログラムを停止するような振る舞いのこと
    - 他の`アクティビティ`によって束縛され終わると、処理が続けられる
    - 並行性の根幹となる(簡単に実装できるらしい)

### 2.4.2 抽象マシン

- 各言語のsemanticsを、操作的意味(抽象マシン上の実行)を通して定義する

#### 定義

- **単一代入格納域σ**
    - 格納域変数の集合
    - 2つの種類の格納域変数が存在しうる
        - 等しいが束縛されていない変数の集合
        - 数、レコード、手続きに束縛された変数群
    - 格納域変数 = **格納域実体**
- **環境E**
    - 

---
    
## question\&comments

- 2.1.1 EBNF
    - 終端記号: token。展開の余地がこれ以上なく、解釈後の文法の末尾になりうるもの
    - 非終端記号: 文法規則。任意の終端記号に置き換えられるもの
- 2.1.2 言語の意味
    - linguistic abstractionとsyntax sugar
    - kotlinのExtensionsはlinguistic abstractionのレベルで言語設計を変更しうるのでは？
    - kotlinがJavaの代替品として振る舞う上で、企業における導入を考えた際、**ある程度誰でも読めて書ける** という(少なくとも弊社での)Java導入のメリットをどこまで射程に入れて考えるか
- 2.2 単一代入格納域
    - 用語整理したい
    - 変数がたくさん入っている箱たち: **格納域**
        - **単一代入格納域** の中には、1つの値としか束縛できない変数がいくつか入る。変数と値は1対1で紐付いている
            - あえてセル格納域や値格納域を使用しなかった
                - 部分値について計算するため
                - 宣言的並行性を保つため
                - 関係プログラミングと制約プログラミングの要求のため
        - 値が変更しうる(immutable)変数は、一時的な保存場所となる **セル格納域** が必要
        - **値格納域** の中の変数は、すべてが値に束縛されている
    - 単一の変数
        - 単一代入格納域の中の変数１つ１つは、特に **宣言的変数** もしくは **データフロー変数** と呼ばれる。
- 2.3.4 レコードと手続き
    - レコードの協力な支援のため可能になるGUIプログラミング
        - AndroidやFlutterを例に考える。Androidの場合、GUI(View)要素は基本的にはXMLを使用して記述する。一方、AnkoといったライブラリやFlutterの場合、"プログラミング言語"でGUIを記述することになる。GUIにおける基本要素はWidgetとして扱われ、それらに属性を与えることで描画の際の特性を与えるといった現在の構造は、レコードのサポートが不可欠である。
- 2.4.1 基本概念
    - 動的スコープが有用なのは、他のコンピュータへある手続きのコードを転送するとき
    - 転送先の変数定義(環境変数？)を参照して実行した方が効率が良い場合がある
    - 脚注; ターゲットマシン上で操作が同様に振る舞うという保証がないため、静的スコープであるべき
    - 結局どっち？
    - マルチコンテナ間の通信など、通常オーケストレーションツールで隠蔽されている点にも該当する話かも

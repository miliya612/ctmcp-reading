# 5. Message-Passing Concurrency

- メッセージ伝達
  - プログラミングスタイル
  - 独立の実体の集合であるプログラムが相互にメッセージを非同期に送信
    - 応答を待たない
  - 重要となる領域
    - **マルチエージェント**
      - エージェント: 独立実体。自身の局所的な目的を持つ
      - 相互作用によって大局的な目的を達成
    - **分散システム**
      - webサービスなどの新技術には非同期処理が必要
    - 高度に信頼性のあるシステム
      - 独立性があり、1つの失敗が全体に伝播しない
      - Erlang

#### 宣言的平行モデルの拡張

- 宣言的平行モデル: 非決定性を持てない
  - client/serverモデル: 返すべきclientが分からない
- メッセージ伝達モデル
  - 宣言的平行モデル + **非同期通信チャネル(asynchronous communication channel)**
  - 宣言的ではない
  - **port**を使用する
    - ストリームが付随するチャネル
    - **port object**
      - portにストリームオブジェクトを紐づけて得られた実体
      - portのストリームから全てのメッセージを読む
      - portを通じて他のport objにメッセージを送信する

## 5.1 メッセージ伝達モデル

- 宣言的平行モデルにportの概念を付加したもの
- port: 通信チャネル
  - 複数スレッドが1つのportにメッセージを送信可能
  - 順序決定性を持たない
- 非決定性を示す
  - 宣言的でない
  - portを使わない部分は宣言的でありうる
    - 宣言的平行モデルの推論技法を利用可能

### 5.1.1. port

- ADT
- 役割
  - `{NewPort ?S ?P}`
    - 入り口P, ストリームSを持つ新しいチャネルorPortを作成
  - `{Send P X}`
    - 入り口Pに対応するストリームにXを載せる
    - ストリームを伸ばす
- 非同期FIFO通信チャネル
- portは常に現在の終わり(末尾)を記憶
  - 末尾は読み出し専用変数
  - 安全なADT
- 非同期
  - メッセージを送信するスレッドが応答を待たない

### 5.1.2. portのsemantics

- **値可変格納域**
  - 宣言的モデルの実行状態を拡張したもの

![5-1:The message-passing concurrent model](https://github.com/miliya612/ctmcp-reading/blob/master/05_message_passing_concurrency/img/5-1.png)

#### 実行状態の拡張

- 格納域
  - 単一代入格納域`μ`
  - トリガ格納域: 遅延性の実現
  - 値可変格納域
- port: `x: y`
  - `x`, `y`: 単一代入格納域の変数
  - `x`: 名前域、portの識別に使用する。一意で偽造不能の定数。
- 値可変格納域
  - 最初は空
  - `x`: portを表す **名前域** に束縛
  - `y`: 束縛されていない
  - 実行状態: `(MST, σ, μ, τ)`

#### NewPort

- 意味言明 `({NewPort <x><y>}, E)`
  - 名前`n`の新しいportを生成
  - `E(<y>)`と`n`を格納域の中で束縛
  - 束縛に成功したら、値可変格納域`μ`に対`E(<y>):(E(<x>))`を追加
  - 束縛に失敗したら、エラーを発生

#### Send

- 意味言明 `({Send <x><y>}, E)`
  - 活性化条件: `E(<x>)` が決定状態である
  - 活性化条件が真の場合
    - `E(<x>)`がポートの名前に束縛されていない場合、エラー
    - 値可変格納域の中に`E(<x>):z`があれば、
      - 格納域に新たな変数`z’`を生成
      - 値可変格納域を`E(<x>): z’`に更新
      - 新しいリスト対`E(<y>)|z’`を生成し、格納域の中でそれを`z`に束縛
  - 活性化条件が偽の場合
    - 実行を待機
- notes: 本当はストリームの終端を読み出し専用ビューとする必要がある


#### メモリ管理

- 値可変格納域変数の導入に伴い、変更が必要
  - 到達可能性の定義の拡張
    - 値可変格納域に`x: y`があり、`x`が到達可能であれば変数`y`は到達可能
  - portの再利用
    - 変数`x`が到達不能になり、かつ値可変格納域に対`x: y`が含まれていれば、その対を削除する


## 5.2. port object

- 1つ以上のportと1つのストリームオブジェクトを組み合わせたもの
- ストリームオブジェクトを2つの方向に拡張
  - 多対一の通信を可能に
    - 多くのスレッドが1つのport objを参照し、独立に送信する
    - ストリームオブジェクトでは実現できない(?: なぜ)
      - 次のメッセージがどこから来るか知る必要があるため
  - データ構造の中に埋め込める
    - メッセージの中にも埋め込める
    - ストリームオブジェクト: 結びついたストリームが1つのスレッドしか拡張できない
- port objの変種
  - `agent`
    - メッセージ交換ができるアクティブな実体
  - `process` Erlangシステム
    - port obj + メールボックス
    - 入ってくるメッセージをパターンマッチングによってフィルタリング
  - 能動的オブジェクト
    - オブジェクト指向的にクラスによってport objを定義
- プログラム: メッセージを送受信するport objの集合
- 分散アルゴリズム: port obj間のアルゴリズム
![portObject.png](https://github.com/miliya612/ctmcp-reading/blob/master/05_message_passing_concurrency/img/portObject.png)


### 5.2.1. NewPortObject抽象

### 5.2.2. 例

### 5.2.3. port objに関する推論

- 相互にメッセージを送信するportObjで構成されるプログラムの推論
  - a. 各portObjそのものが正しいこと
    - portObjを1つのデータ抽象として定義
      - **不変表明**を必ず持つ
        - ある抽象操作の完了と、次の操作の開始の間で真になる表明
    - データ抽象(portObj)が正しい==表明の不変を示せる
    - Sec3.宣言的モデルの方法を踏襲できる
      - portObjの内部は宣言的であるため
        - ストリームを含む再帰的関数
    - 証明すべきこと
      - portObjの初期生成時、表明が成立
      - msg操作前に表明が成立しているとき、操作後にも表明が成立
  - b. 全体が正しく協働すること
    - 各portObjが受信するmsgの列としてありうるケースを定める
      - ->システム中の全てのイベントを分類する
        - msg送信
        - msg受信
        - portObjの内部状態変更
      - ->イベント間の因果関係を定める
        - あるイベントが別のイベントより前に起きるかどうか
        - portObjで構成されるシステムを状態遷移システムと捉える

## 5.3. 簡単なメッセージプロトコル

- portObjがmsg交換を通して協働するための統制
  - 統制: プロトコル定義
  - プロトコル
    - > 2つ以上の関係者の間のメッセージの列で、単なる個々のメッセージ以上の抽象化レベルにあると了解されるもの
    - eg. TCP/IP, HTTP, FTP, Ethernet, DHCP,...
    - msg図式
      - **遊休スレッド** と **待機中スレッド**を区別
      - requestに答えうる状態か否か


![5-3:Message diagrams of simple protocols
](https://github.com/miliya612/ctmcp-reading/blob/master/05_message_passing_concurrency/img/5-3.png)

### 5.3.1. RMI(遠隔メソッド起動)

- remote method invocation
  - > あるオブジェクトが他のオペレーティングシステムのプロセスの中にあるイブジェクトを呼べるようにするもの
    - 対向OSの場所は同一マシン内に限らない
  - RPCの子孫
    - 呼び出される遠隔実態がprocedureからobjectに変わった
    - method: ここではOOPに限らず、portObjがmsgを受信したこと
- プログラマにとっては簡単
  - clientからserverに要求を送り、serverからresponseが返るのを待つだけ
- RMI実装の最善の方法
  - すべてのmsgをserverが直列に実行するもの
    - プログラムが簡単
    - 推論しやすい
  - 異なるclientから複数呼び出しができて、それらが平行に処理されるもの
    - server側で複数スレッドを実行する
    - serverは他の要素による影響から内部データを守る必要がある
- 言語と環境
  - ここでは同じ言語、同じOSProcessの中で実行
  - 分散システムプログラミングにも適用可能
    - Javaを走らせる2つのOSProcess: `Java RMI`
    - 異なった言語による2つのProcess: `CORBA(Common Object Request Broker Architecture)` or Webサービス

### 5.3.2. 非同期RMI

- 非同期RMI
  - 2つのrequestを続けざまに送れる
    - clientはrequestを送った直後から実行を続けられる
    - responseが届くとclientに通知される
  - client \- server間の通信が遅い場合、RMI比で性能向上を見込める

### 5.3.3. callbackのあるRMI(スレッド使用)

- serverが実行のための要求を満たすため、clientを呼び出す必要があるケース
  - serverがclientのとあるパラメータを必要とするケース
- 単純なRMIの場合、デッドロックに陥る
  - clientはserverから予期したresponseが返るまで待機状態に陥る
- callbackを受け取れるようにする
  - clientが応答を待たずに実行を続けられるようにする
  - 待機用のスレッドを生成する
  - **同期の責任をclientから、使用するアプリケーションに転嫁する**
    - 使用するアプリケーション==clientからのresponseを使用するserver?
    - デッドロックの原因は、同期の責任をclientに求めていたため

### 5.3.4. callbackのあるRMI(継続のためのレコード使用)

- スレッド生成のコストが高価、もしくは生成自体が許されない場合を考える
- clientがserverに継続を表すレコードを渡す方法
  - serverは処理が終了したら、clientにレコードを返し、clientは処理を進める
    - clientは`cont(z)`をserverに送る
    - serverは`cont(z)#Y`をclientに返す
    - clientはパターンマッチングを利用し、`const(z)#Y`が返ってきた場合に後続の処理を進める

### 5.3.5. callbackのあるRMI(継続のための手続き使用)

## 5.4. 並行性のためのプログラム設計

- 平行コンポーネントを使う、コンポーネントベースプログラミングについて

### 5.4.1. 平行コンポーネントを使うプログラミング

- 平行アプリケーションの設計: 平行アクティビティのモデル化
  - 1アクティビティ: 1コンポーネント
    - コンポーネント == `agent`
    - reactive(内部状態を持たない) or 内部状態を持つ
  - **MAS(multiagent system)** とも
  - agent: 一般的に知性を持たない非常に単純な実体
    - 人工知能の分野では、agent自体が推論を行うことも

#### 平行コンポーネント

- モデルの定義
  - portObjを基にして並行的msg伝達を行う
  - 平行コンポーネント: 入力と出力を持つ手続き
    - 起動後、コンポーネントの具体化(portObjを生成)
    - 入力はport、ストリームはコンポーネントによって読まれる
    - 出力はport、コンポーネントが送信する
- 平行コンポーネントをモデル化する正しい概念は手続き
  - 手続き: 合成的、任意個の入力と出力を持てる
  - サブコンポーネントを合成するとき、入出力の可視性を内部のみに限定出来る

#### インタフェース

- 平行コンポーネントはインタフェースを通じて相互作用する
  - インタフェース
    - 入出力の集合、`wire`
    - 1つ以上の出力を1つ以上の入力につなぐ
    - 基本的wire
      - 1回性(one-shot)
        - データフロー変数で実装
        - 変化しないor1回限りのmsgに対して使用
        - 1つのmsgのみを渡し、1入力に1出力のみを結びつける
      - 他回性(multi-shot)
        - portで実装
        - msgストリームに対して使用
        - msgをいくつでも渡せ、1入力に複数出力を結びつける

#### 基本操作

1. **Instantiation**
  - コンポーネントの具体を生成
    - デフォルト:それぞれが独立である
    - 全ての具体が共通の具体への依存を持つことも
      - webappのconfig系など
2. **Composition**
  - 基になるコンポーネントから新しいコンポーネントを構築
    - コンポーネント間の関係により、メインとサブと呼ばれる
    - 構築してできるコンポーネントは独立・平行
    - 直列システムにおける合成コンポーネントは依存関係にある
3. **Linking**
  - 入力と出力を結びつけることで、コンポーネントの具体を結びつける
  - 入出力に結び付けられる数によって、1回性と多回性と区別
    - 1回性
      - 1出力に多入力が紐付き
      - 全入力は同じ値
    - 多回性
      - 複数出力が複数入力に紐付き
      - 全入力は同じストリーム
4. **Restriction**
  - 入出力の可視性をコンポーネント内部に制限
    - サブコンポーネントのインタフェースwireの一部を新コンポーネント内部に制限
      - wireがインタフェースに現れない

- ディジタル論理回路の例
  - wire:`DI` `DO`のみが外部から可視
```
proc {Latch C DI ?DO}
  X Y Z F
in
  {DelayG DO F}
  {AndG F C X}
  {NotG C Z}
  {AndG Z DI Y}
  {OrG X Y DO}
end
```

### 5.4.2. 設計方法

- 並行プログラムの難しさ: 部分間の相互作用が直列に比べて多い
- 曖昧さのない一連の設計規則が必要
  - **形式張らない仕様**
    - システムがすべきことを正確な仕様として書く
    - 形式張ったものでなくてよい
  - **コンポーネント**
    - 仕様の中の、様々な形の平行アクティビティを残らず列挙する
    - 各アクティビティが１コンポーネントになる(?:アクティビティとはどの単位？)
    - すべてのコンポーネントの具体化を載せた、システムのブロックダイアグラムを描く
  - **メッセージプロトコル**
    - コンポーネントが送るメッセージを定め、コンポーネント間のメッセージプロトコルを設計する
    - すべてのメッセージプロトコルを添えたコンポーネントダイアグラムを描く
  - **状態ダイアグラム**
    - 平行実体ごとにその状態ダイアグラムを描く
    - 状態ごとに下記を検証
      - すべての適切なメッセージが、正しい条件・アクションを伴って送受信されること
  - **実装とスケジューリング**
    - コーディングする
    - コンポーネント間の並行性を実装するのに使用するスケジューリングアルゴリズムを決定する
      - ref. https://ja.wikipedia.org/wiki/%E3%82%B9%E3%82%B1%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0#%E3%82%B9%E3%82%B1%E3%82%B8%E3%83%A5%E3%83%BC%E3%83%AA%E3%83%B3%E3%82%B0%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0
  - **テストと繰り返し**
    - システムをテストし、最初の仕様を満たすまで繰り返す

### 5.4.3. 並行性パターンとしての機能的構成要素

- 平行コンポーネントを用いると多くのメッセージプロトコルが生じる
- ？

## 5.5. リスト制御システム

- リフト制御システムを平行プログラムとして設計する
- model

![5-4:Schematic overview of a building with lifts](https://github.com/miliya612/ctmcp-reading/blob/master/05_message_passing_concurrency/img/5-4.png)

- component diagram
  - 4components
    - Floors
    - Lifts
    - Controllers
      - Controllers are used to handle lift motion. 
    - Timers
      - Timers handle the real-time aspect of the system


![5-5:Component diagram of the lift control system](https://github.com/miliya612/ctmcp-reading/blob/master/05_message_passing_concurrency/img/5-5.png)

(?: 階数をLiftに持たせない理由は何か)

### 5.1. 状態遷移図

- portObjの設計方法
  - 取り得る状態と、送受信するメッセージを列挙する
  - 全状態における適切な処理のチェックが用意になる
- **状態遷移図**(state transition diagram)
  - **有限状態オートマトン**(finite state automaton)
  - 状態の有限集合と状態間の遷移の集合で出来ている
  - 遷移はatomicな操作
    - メッセージを受信
      - 適切なメッセージかどうかのbool条件が付随
    - 条件が真であれば遷移が可能
    - 遷移がメッセージを送り、状態を変える

![5-6:Notation for state diagrams](https://github.com/miliya612/ctmcp-reading/blob/master/05_message_passing_concurrency/img/5-6.png)

- メッセージの送り方
  - portに送信
  - データフロー変数を束縛
    - 1回性wire
    - 1つのメッセージしか送れない軽量級チャネル
- メッセージの受け取り方
  - ストリームから受信
  - 束縛を待つ
- timerプロトコル
  - 呼び出し側がtimerAgentに秒数指定したメッセージを送る
  - timerAgentは指定された秒数経過後、呼び出し側にメッセージを返す
  - `{Delay N}`の平行コンポーネント版

#### リフト制御システムに関する推論

- > スケジュールの隣り合う要素は必ず異なることの証明

```
fun {ScheduleLast L N}
   if L\=nil andthen {List.last L}==N then L
   else {Append L {N}} end
end
```


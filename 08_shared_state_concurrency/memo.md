- **状態共有並行モデル(shared-state concurrent model)**
  - 宣言的並行モデルの拡張
    - 明示的状態を付加
      - 値可変変数のcellを追加
  - メッセージ伝達並行モデルと同じ表現力
    - cellはportを用いて効率的に実装できるたね
- **状態あり並行モデル(stateful concurrent model)**
  - 状態共有並行モデル
    - 複数のスレッドが共有データに並行にアクセス
    - 難しい
  - メッセージ伝達並行モデル
    - マルチエージェントプログラム

#### このモデルの本質的な難しさ

- 状態共有モデル
  - 実行は複数スレッドで構成
  - 各スレッド
    - 独立に実行
    - 共有セルにアクセス
  - 1つのスレッドの実行はatomicな命令の列
  - 操作
    - `@`: アクセス
    - `:=` 代入
    - `Exchange`: 交換
  - 1つの大域的な操作順序があるものとして実行される
    - interleave semanticsによる
- 全てのスレッドの全ての操作は、操作順序を形成するためにinterleaveされる
  - interleaveは数多く起こる
    - データの依存関係のみが数に制限をかけられる
      - ある計算が別の計算の結果を必要とすること
  - 任意の実行はinterleaveの現れとなる
  - どのようにinterleaveされるかは分からない
    - スレッドスケジュールの非決定性のため
- 状態共有モデルで書かれたアルゴリズムの正しさの証明技法
  - すべての起こりうるinterleaveについて推論する
    - 見逃しやすい
    - プログラムの大きさに伴って実用的でなくなる

#### なぜ、宣言的並行性を使わないのか

- 状態共有並行モデルより簡単な宣言的並行モデルでは対処できない理由について
- 宣言的並行モデルの簡単さ
  - データフロー変数が`monotonic`であるため
    - 1つの値にしか束縛されない
    - 1度束縛されると変更されない
    - データフロー変数を共有するスレッドは、あたかも単なる値として扱うことができる
      - e.g.ストリームを共有するスレッド
  - 一方、cellは非単調
    - 無関係な値を再代入できる
    - cellを共有するスレッドは、cellの内容を想定して扱うことができない
- 宣言的並行モデルの課題
  - スレッド同士が`lockstep`, `systolic`に通信しなければならないこと
    - 独立に実行できない
    - 協調して実行されなければならない
      - 宣言的並行モデルを宣言的かつ決定的にしたらしめる所以
  - スレッド同士を独立して振る舞わせたい、第3のスレッドと通信したい
    - e.g.
      - 複数clientが1serverに独立に、互いに協調せずにrequestを送りたい
      - 共有状態のcounterを独立にincrementしたい
    - 観測可能な非決定性が表出する
      - 明示的状態が必要となる
        - 宣言的モデルからの離別が必要
      - `port`, `cell`が解決してくれる

#### 困難さを回避すること

- 状態共有並行モデルをそのまま推論するのは困難
  - 何かしらの工夫が必要
- 状態あり並行モデルでプログラムすること
  - **Interleaveを管理すること**
    - 手法
      - portオブジェクト間でメッセージ伝達を行う(Sec.5)
        - プログラムをportオブジェクトで構成
          - 相互に非同期的にメッセージを送信しあう
        - portオブジェクトの内部
          - 1つのスレッドで実行する
      - 共有cellについてのatomicなアクションの集まりとして構成する(Sec.8)
        - プログラムをスレッドによって起動される*受動的な*オブジェクトで構成
        - 抽象を用いて、大きいatomicなアクションを構築する
          - e.g. lock, monitor, transaction,...
          - 起こりうるInterleaveの数を減らせる

## 8.1. 状態共有並行モデル

- これまでのおさらい
  - 宣言的モデルについて
  - 宣言的モデル+明示的状態(Sec.6)
    - オブジェクト指向プログラミングの実現
  - 宣言的モデル+並行性(Sec.4)
    - 独立に進化する能動的実体が複数存在しうる
      - 独立: 他に依存せず実行できる
      - 進化する: 時間的に成長する(?:だった気がする)
      - 能動的: 自身がメッセージを送信する
      - 複数: 1つだったら並行じゃなくていい
  - 宣言的モデル+明示的状態+並行性
    - portを用いる方法(Sec.5)
    - cellを用いる方法(NEW!)
- 状態共有並行モデル(shared-state concurrent model)
  - 宣言的モデルに下記を加えたもの
    - 明示的状態
    - 並行性
  - cellを用いて実現したもの

(図8.1)
(表8.1)

## 8.2. 並行性を持つプログラミング

### 8.2.1. さまざまな手法の概観

- これまでに見てきた並行プログラムを書くための実用的手法
- **直列プログラミング**
  - 基礎的手法
  - 並行性を持たない
  - 実行は性急的か遅延的でありうる
- **宣言的並行性**
  - 宣言的モデルの範囲内で並行性を実現する
  - 基本的には直列プログラムと同じ結果を出す
    - 違い: 結果を漸増的に出すことができる
  - 観測可能な非決定性が無いときに実用可能
  - 実行は性急的か遅延的でありうる
    - 性急的: データ駆動並行性
    - 遅延的: 要求駆動並行性
- **メッセージ伝達並行性**
  - portオブジェクト間のメッセージ伝達を行う
  - portオブジェクト内部は直列で実行される
    - Interleaveの組み合わせ数を制限できる
  - 変種: 能動的オブジェクト
    - オブジェクトの振る舞いはclassによって定義される
- **状態共有並行性**
  - スレッドが*きめの粗い*atomicなアクションを使って受動的な共有オブジェクトを更新する
  - Interleaveの組み合わせ数を制限できる

(図8.2)

#### 直列プログラミング

- 全ての操作に全順序がある
  - プログラムが持ちうる最も強い*順序不変関係*を持っている
- 直列モデルでありながら、順序をちょっと緩める(柔軟に決定する)方法
  - **順序決定(order-determing)並行性**
    - すべての操作が全順序において実行される
      - 直列実行同様
    - 順序が動的に決まる
      - データフローによって並行に実行される
      - programmableでない
  - **コルーチン化**
    - **横取り**が明示的である
      - activeな制御を別のスレッドに渡す時期がprogrammableである
    - 直列プログラムに遅延性を付加した遅延計算
- 決定性を持つ

#### 宣言的並行性

- 宣言的モデルにスレッドを追加したもの
- 計算結果は変わらないが、結果が出る順序が変わる
  - e.g. 結果が漸増的に出てくる
  - 動的(?:動的をどう説明しようか)ネットワークの構築が可能
    - 並行ストリームオブジェクトをストリームで結合して実現
- 並行性の貢献
  - ストリームオブジェクトが*直ちに*出力を生産することができるようになる
    - 他のon-goingな入力を待たなくてよい
    - 入力ストリームに要素が追加*されていく*
- 実装の中に非決定性を持つ
  - システムがスレッドをどう進行させるかを選択するため
- 宣言的並行モデルは非決定性をプログラムから隠蔽する
  - 宣言的であり続けられる
  - ただしException発生を除く
    - Exception: 観測可能な非決定性の目撃者であるため
      - 非決定性に基づく予期できない値に応じて発生するから
  - 結局、どのストリームオブジェクトも、次の入力がどのストリームから来るかを常に知っていなければならない(?:要かみくだき)
    - どのストリームから入力が来るか分からない状態: 入力元が非決定的
    - 宣言的である: 決定的である
- 要求駆動並行性
  - == 遅延実行
  - 計算結果は変わらない
  - 結果を得るために必要な計算量が異なる
    - 必要とされた分しか計算しない
    - 必要とされて初めて計算を始める
    - 資源, リソース管理にとって重要な特性
  - 要求駆動にしか実行できない場合がある
    - データ駆動モデルでは無限ループに陥る
  - `by-need`トリガを使って実装する

#### メッセージ伝達並行性

- 状態あり並行モデルの基本的なプログラミングスタイル
- 宣言的並行モデル+`port`
  - 簡単な通信チャンネル
- プログラムはportオブジェクトのネットワーク
  - portオブジェクトが相互に非同期メッセージ伝達で通信
  - portオブジェクト
    - ストリームオブジェクトの拡張
    - 入力元をストリームからportに変更したもの
    - 自身で各メッセージをいつ処理するか決定する
      - メッセージは直列に処理される
      - Interleaveの組み合わせ数を制限する
      - *不変表明*を用いた推論が可能に
- 推論は因果連鎖に依拠している必要がある
  - システム上で発生するイベントの間には因果関係がある
    - port間のメッセージの送受信のイベント
      - 送信
      - 受信
      - 内部処理
    - あるportがメッセージを送信したことで他のportがメッセージを受信する
- (?:goのchannel、CSPのプリミティブな操作?)

#### 状態共有並行性

- 状態あり並行モデルの基本的なプログラミングスタイル
- スレッドの集合で構成
  - スレッド
    - 受動的な共有オブジェクトの集合にアクセスする
    - きめの粗いatomicなアクションを用いる
      - lock, monitor, transaction,...
  - Interleaveの組み合わせ数を制限する
  - 不変表明による推論が可能に
- (?:goのsync packageとか、メモリ共有同期のおはなし？)

#### portとcellの関係

- メッセージ伝達モデルと状態共有並行モデル
  - 表現力において同等
  - port, cellはそれぞれ互いを用いて実装可能である
- 宣言的並行モデルにcellとportどちらかを選んで実装できる……**わけではない**
  - 2つの目指すプログラミングスタイルは極めて異なる
  - 適するアプリケーションの種類が異なる
- メッセージ伝達*スタイル*
  - 相互に協調する能動的実体としてのプログラム
- 状態共有並行*スタイル*
  - 首尾一貫した方法で修正される受動的なデータの集まりとしてのプログラム

#### その他の手法

- 4つ(直列、宣言的並行性、メッセージ伝達並行性、状態共有並行性) and more...
- **状態あり並行モデルを直接使うこと**(?:)
  - メッセージ伝達スタイルで書く
    - スレッド, port, データフロー変数を用いる
  - 状態共有並行スタイルで書く
    - スレッド, cell, データフロー変数を用いる
  - 折衷スタイルで書く
    - cellとportを両方用いる
- **非決定性並行モデル**
  - 宣言的並行モデル + *非決定性選択演算子*
  - 状態あり並行モデルへの足がかりとなる

#### どの並行モデルを使うべきか

- 指針
  - プログラムに十分なモデルを用いる。必要最小のものをはみ出さないようにする。
    - 並行性を用いてもアーキテクチャが改善されないなら、直列モデルで書ききるべき
    - 観測可能な非決定性がないならば、宣言的並行モデルで書ききるべき
      - 独立のclientがserverと相互通信するなど
  - どうしても状態と並行性が必要なら、メッセージ伝達か状態共有並行を使う。
    - multi agentプログラムにはメッセージ伝達が最適なことが多い
      - multi agent: 相互に通信するagent(自律的実体)が集まってできるプログラム
    - **データ中心プログラム(data-centered program)** には状態共有並行が最適なことが多い
      - データ中心: 並行的にアクセス・更新されるデータの貯蔵所でできている
        - **DataBase**
    - 1アプリ内で部分によって使い分けることも可能
  - プログラムをモジュール化し、並行性を必要とする箇所をできるだけ少なくする。
    - たいていの場合、プログラムは直列or宣言的並行性で済む
    - 方法
      - インピーダンスマッチングを行う
      - 能動的オブジェクトを受動的オブジェクトのフロントとして使う
        - 受動的オブジェクトを呼び出すのが能動的オブジェクトただ1つになる
        - 直列モデルで済む(?:よき)

#### 並行性が多すぎるのは良くない

- **最大並行モデル(maximally concurrent model)**
  - 特徴
    - 状態共有並行モデルよりも更に並行性が高い
    - 各操作がそれ自身のスレッドで実行する
    - 実行順序を制限するのはデータの依存関係だけ
  - 実験的並行プログラミング言語の基礎となる
    - プログラム, 効率的な実装が困難
      - 操作がスケジューリングと同期のオーバーヘッドに比べてきめ細やか
  - 変種が制約プログラミングで利用される
  - cf. 状態共有並行モデル
    - スレッドを明示的に生成する
    - きめの精粗はプログラマによって制御される

#### 状態共有並行モデルを直接使うこと

- 困難
  - プログラムを正しく動作させるのが難しい
    - 膨大な数のInterleaveの組み合わせが存在しうる
  - 高水準な手法で解決を試みる
    - 能動的オブジェクト
    - atomicなアクション
- 直接用いるのが効果的な場合
  - 状態共有並行モデルでは何が出来るのか
    - スレッド、手続き、cell, データフロー変数を用いてプログラムすること

#### 並行スタック

- **並行データ抽象(concurrent data abstraction)
  - 複数のスレッドが同時に実行できるようなデータ抽象
  - eg. オブジェクトスタイルのスタック
    - ブロックすることのない`push`, `pop`を提供する
    - 外部要因によって待機することなく、すぐに成否を告げる
    - 簡単な並行スタック
      - 各操作が1つのExchangeを行うだけだから
      - 抽象の操作が2つ以上のcell操作を伴うと複雑になる
  - 抽象の操作が正しい
    - cell操作がatomicに行われなければならない
      - 能動的オブジェクトかatomicアクションを用いるべき

```
fun {NewStack}
  Stack={NewCell nil}
  proc {Push X}
  S in
    {Exchange Stack S X|S}
  end
  fun {Pop}
  X S in
    {Exchange Stack X|S S}
    X
  end
in
  stack(push:Push pop:Pop)
end
```

- `Exchange`
  - 操作内容
    - cellの内容にアクセスする
    - cellに新しい内容を代入する
  - atomicな操作
    - 並行環境で利用可能
  - `push`, `pop`もInterleaveに関わらず正しく動く
    - それぞれ1つのExchangeを実行するだけだから
  - 唯一の制限
    - 空のスタックを`pop`してはならない
    - Exceptionが起こる

```
fun {Pop}
X S in
  try {Exchange Stack X|S S}
  catch failure(...) then raise stackEmpty end end
  X
end
```

#### 遅いネットワークをシミュレートすること

- **トークン伝達によりメッセージの順序を維持すること**
  - 問題
    - スレッド間の順序整合性が保てないことがある
    - 複数スレッドによって操作されるオブジェクトの状態に矛盾が生じる恐れがある
  - メッセージの順序を維持したい
  - オブジェクトの中で同時に1つのスレッドしか実行しないことを保証したい
  - **トークン伝達(token passing)**
    - プログラムのある部分の実行順序を強制的に守らせる
    - 実装方法
      - データフロー変数の列`X0, X1, X2,...`を生成する
      - 同じ順序で実行すべき操作に逐次、対`(X0, X1), (X1, X2),...`を渡す
      - 対`(Xi, Xi+1)`を受け取った操作は下記を順に行う
        - tokenの到着を待つ
          - `Xi`が束縛されるのを待つ(`{Wait Xi}`)
        - tokenが到着したら計算を行う
        - tokenを次の対に送る
          - `Xi+1`を束縛する(`Xi+1=unit`)
    - オブジェクト呼び出しを順序キューに入れることに等しい

### 8.2.3. atomicアクションを使うプログラミング

- lockを導入し、それを用いてmonitor, transactionを定義する
- lock
  - 小さなatomicな操作を集めて、より大きなものを構成できる
  - lockを**代入可能(reentrant)** にする
    - プログラムの不連続部分を防護できる(?:不連続な処理をatomicにできる？)
  - lockのある部分にあるスレッドは、そのlockの任意の部分に待たずに再び入ることができる
    - (?:途中からlockに割り込める？)
- monitor
  - lockに**待機点(wait point)** を設けたもの
    - 出口と対応する入り口の対
    - 途中のコードを取り除いたもの
    - ==**遅延点(delay point)**
  - スレッドは、lockのすぐ外の待機点で留まることができる
  - 出て行こうとするスレッドは、停まっているスレッドを再始動させることができる
- transaction
  - lockからの出方を2つ設けた
    - **commit**
      - 正常な出方
    - **abort**
      - 例外的な出方
      - transaction実行中のいつでもabortされうる
      - abortされると、transactionは実行状態を入力前に戻す

(図8.4)
(図8.5)

#### atomicアクションを使う推論

- 一貫してatomicな操作のみを使用するプログラム
- プログラムを正しいと証明する
  - 各atomicなアクションが正しいことを証明する
    - lock, monitor, transactionなどのatomicなアクションが正しいことを証明する
    - 各atomicなアクションはそれぞれ1つのデータ抽象を定義する
      - 不変表明を持つ
      - 抽象の中にスレッドがない場合に真となる表明
        - 直列で処理され、Interleave実行が起こりえないときに真となる
      - 数学的帰納法を用いて証明する
        - データ抽象が最初に定義されるとき、表明が成り立つ
        - あるスレッドがデータ抽象から出るたびに、表明が成り立つ
    - 状態ありプログラムと能動的オブジェクトに関する推論に似ている
      - データ抽象が並行的にアクセスされることを除く
  - プログラムが各アクションを正しく使っていることを証明する

## 8.3. ロック

- **lock**
  - 言語概念
  - usecase
    - 複数スレッドが共有資源にアクセスしたい
    - 資源は同時に1つのスレッドしかアクセスできない
  - **危険領域(critical region)**へのアクセスを動的に制御する
  - 基本操作
    - 危険領域への排他的アクセスを確実にする
    - 領域の中で同時に1つのスレッドしか実行しないようにする
  - 共有資源へのアクセスを危険領域の中からのみ可能にする
    - lockを用いれば共有資源へのアクセスを制御可能に
- 共有資源のパターン
  - プログラム内
    - オブジェクト,...
    - 字句的スコープにより、危険領域の外から参照できないように
  - プログラム外
    - OS資源
    - プログラムレベルの保証はできないが、原則としてそうなっている
- アクセス制御とlockには様々なパターンがある
  - これまで見てきた言語実体を使ってOzで実装できる
    - cell, スレッド, データフロー変数
  - **スレッド再入ロック(thread-reentrant lock)**
    - 言語レベルの支援が存在する
    - 操作
      - `{NewLock L}`
        - 新たなlockを返す
      - `{IsLock X}`
        - Xがあるlockを参照しているとき、`true`を返す
      - `lock X then <stmt> end`
        - `<stmt>`をlock`X`で防護する
        - `X`で防護された文を実行しているスレッドがなければ、任意のスレッドが入ることが出来る
        - あるスレッドが防護された文を実行しているとき、そのスレッドが入れ子の実行において同じlockに出会えば再度入ることが出来る
          - (?:lockはあくまで操作単位で働く、ということ?)
        - あるスレッドが、防護された文に入ろうとするとき、別のスレッドが同じlockで防護された文の中にいれば、最初のスレッドは待たされる
          - (?:lockの意義はコレ)
        - 同じlock`X`に対して、`lock`文は何度でも呼べる
          - 危険領域は連続している必要はない(?:)
        - 防護部に高々1つのスレッドしか存在しないことを担保する

### 8.3.1. 状態あり並行データ抽象を構築すること

- 状態あり並行データ抽象を段階的にプログラミングしていく
  - 宣言的データ抽象を組織的に状態あり並行データ抽象に変換する
- 宣言的実装
  - 好ましくない
    - 操作の順序がプログラムにおいて定められている
      - 空のqueueへのdeleteをinvokeした場合、insertを待ってしまう
    - 異なる操作を行うスレッド間が同期を取ってしまう
- 状態あり実装
  - データをカプセル化した状態あり実装
  - 並行実行した際、状態変更が競合する
    - atomicな操作となってない
- 状態ありqueueの並行版
  - lockを用いて操作をatomicにしている
    - スレッド間の同期を取る必要はない
  - 状態を使うことによるもの
    - 状態操作を行うスレッドを高々1つにすることで整合性を担保している
- オブジェクト指向構文で書いた、状態ありqueueの並行版
  - lockはproperty`locking`で暗黙的に定義される
- `Exchange`を用いた別の方法での並行実装
  - 全ての操作において、状態操作は`Exchange`ただ1つのみである
    - 元々atomicである
    - lockが不要となる
  - > 算術演算子N-1とN+1はExchangeのあとに行わなければならない. なぜか？
    - 空のqueueに対してdelete操作を行った場合、データフロー変数により実行は待機状態へと遷移する。その際、Exchange操作よりも先に文中の算術演算を行うと、第一引数に示されるqueueの要素数と実体に乖離が発生するため。

- まとめ
  - 宣言的実装
    - 最も簡単
    - 独立スレッドあいだの共有資源を扱う方法としては使えない
  - 状態ありqueueの並行版、`Exchange`を用いた実装
    - 妥当
      - 状態ありqueueの並行版
        - lockを用いてatomic性を実現できる
      - `Exchange`を用いた実装
        - コンパクトだが、単一データ列を処理する操作に限られる
          - 複数のデータをExchangeを用いて操作し得ない

### 8.3.2. タプル空間(Linda)

- 並行プログラムのためによく行われる抽象
- 2つの役割
  - 理論面
    - 並行プログラミングの最初のモデル
  - 実用面
    - 並行プログラムのための有用な抽象
    - どんな言語にも付加でき、その言語を並行的にできる
      - eg. C-Linda: LindaつきのC言語
- == **協調モデル(coordination model)**
- タプル空間抽象付きのプログラミング言語: **協調言語(coordination language)**
- 定義
  - タプルのマルチセット`TS`
  - 基本操作
    - `{TS write(T)}`
      - タプル`T`をタプル空間`TS`に加える
    - `{TS read(L T)}`
      - タプル空間に、ラベル`L`のタプルが少なくとも1つ入るのを待つ
      - その後、タプルを1つ削除し、`T`に束縛する
    - `{TS readnoblock(L T B)}`
      - 待機せずにすぐ戻る
      - タプル空間にラベル`L`のタプルがなければ`B=false`
      - タプル空間にラベル`L`のタプルがあれば`B=true`とし、そのタプルを1つ削除して`T`に束縛する
  - 通常, Lindaは読み込み操作でパターンマッチングを行う
  - 性質
    - **内容アクセス可能メモリ(content-addressable memory)** を持つ
      - タプルはそのラベルで識別される
    - 読み手と書き手が切り離される
      - 基本操作以外の通信を読み手と書き手は行わない

#### 並行キューを実装すること

- cellの代わりにタプルを使って実装する
- lockは不要
  - `read`操作がatomicにタプル空間からタプルを取り除くから
  - タプルが、タプル空間とキュー操作の間でやり取りされる一意のtokenと見なされる

#### タプル空間を実装すること

- lock, 辞書, 並行キューを使って実装する

## 8.4. モニタ

- 必要性
  - 有界バッファの例
    - lockだけだと、バッファが一杯であったときの動作に問題がある
    - スレッドはバッファに空きが出るまで待ち、その後後続の処理を進めるようにしたい
  - 複数のスレッドを協調させる方法が必要
    - バッファから要素を取り除くスレッドが、バッファに空きが出たことを他のスレッドに伝える、など
- **モニタ(monitor)**
  - 状態ありモデルにおいて、スレッドを協調させる標準的技法
  - 広く使われている
    - javaの基本概念
  - lockを拡張し、待機中のスレッドがlockに出入りするのをプログラムで制御する
    - 並行アクティビティの間で共有する資源として使える(?:)
  - 制御の与え方
    - モニタが待機中のスレッドの1つの集合である場合
    - 待機中のスレッドのいくつかのキューである場合
- > モニタが待機中のスレッドの1つの集合である場合
- モニタの操作
  - lockの入出操作
  - モニタ独自の操作
    - `wait`操作
      - スレッドを待機状態にし、モニタのwait集合に入れ、モニタのlockを手放す
    - `notify`, `signal`操作
      - モニタのwait集合中の1つのスレッドを再開させる
      - 再開したスレッドが再びモニタのlockを獲得しようとする
      - 成功すれば、中断したところから実行を再開する
    - モニタの内部だけから呼び出し可能

### 8.4.1. 定義

- モニタ(java版)の定義
  - 常にオブジェクトの一部
  - 内部lockとwait集合を持つオブジェクト
  - `synchronized`修飾子をオブジェクトに添える
    - オブジェクトのメソッドをlockによって防護できる
  - 操作
    - `wait`
      - 現在のスレッドを待機
      - スレッドをオブジェクトのwait集合に入れる
      - オブジェクトのロックを開放する
    - `notify`
      - オブジェクトのwait集合にスレッドがあれば、任意の1つ`T`を取り除く
      - `T`がlockを獲得しようとする
          - `notify`してくれたスレッドがlockを解放するまで待機する
        - `T`は待機したところから実行を再開する
    - `notifyAll`
      - wait集合にある全てのスレッドに`notify`操作を行う
        - wait集合が空になる
    - lockを把持しているスレッドが呼べる
  - 共有状態を基礎として並行データ抽象を構築するために設計された
    - モニタの言語抽象を用意している言語もある
    - コンパイラで検証可能に
      - `wait`や`notify`がモニタlockの中でしか実行されていないこと
      - 共有変数がモニタを通じてしかアクセスされないこと

### 8.4.2. 有界バッファ

- モニタを使った有界バッファの実装
- 有界バッファの宣言的実装(4章)
  - 性急ストリーム通信
  - 遅延ストリーム通信
- 操作
  - `B={New Buffer init(N)}`
    - 大きさ`N`の新しいバッファ`B`を生成する
  - `{B put(X)}`
    - 要素`X`をバッファに入れる
    - バッファが一杯であれば、空きが出るまでブロックする
  - `{B get(X)}`
    - バッファから`X`に要素を取り出す
    - バッファが空であれば、少なくとも1つの要素が入るまでブロックする
- 実装
  - 循環配列を用いる
  - バッファが一杯のとき、`M.wait`を呼ぶ
  - `wait`から復帰する際、再度`put`を呼ぶ
    - 他のスレッドが先に`put`してしまい、バッファが一杯になってしまっているかもしれないから
    - 必ず要素追加の直前に条件分岐を通るようにする
  - 宣言的遅延実装版の方が簡単
  - 観測可能な非決定性がなければ宣言的並行版も使える
    - 書き手も読み手も1つである一対一通信の場合
    - 多くの読み手が全て同じものを読む場合
  - モニタ版の使いみち
    - 独立の書き手が2つ以上の場合
    - 独立の読み手が2つ以上の場合

### 8.4.3. モニタを使うプログラミング

- 有界バッファ実装に使ったモニタを用いたプログラミング技法を一般化する
- 仮定
  - 並行データ抽象を1つのクラスで完全に定義しようとする
- 考え方
  - 各メソッドを、防護されている危険領域とする(**条件付き危険領域**)
    - あるスレッドがメソッド本体に入るためには、条件が真でなければならない
    - 条件が偽であれば、スレッドが待機する

```
% 防護されたメソッドの例
meth methHead
  lock
    while not <expr> do wait; % <expr>: 防護条件
    <stmt> % 防護された本体
    notifyAll; % 待機中のwait集合にいるスレッドに、続行できることを伝える
  end
end
```

### 8.4.4. モニタを実装すること

- wait集合
  - キューを用いる
  - 最初にモニタに入る機会が最長待機スレッドに与えられるので、餓死(starvation)が起きない(?:)
  - 再入lockの有用性を示す
    - `DeleteNonBlock`の中で`Size`と`Delete`を呼んでいる
    - lockが再入可能でなければ動かない

```
fun {NewQueue}
  ...
  fun {Size}
    lock L then @C.1 end
  end
  fun {DeleteAll}
    lock L then
      X q(_ S E)=@C in
      C:=q(0 X X)
      E=nil S
    end
  end
  fun {DeleteNonBlock} lock L then
    if {Size}>0 then [{Delete}] else nil end end
  end
in
  queue(insert:Insert delete:Delete size:Size deleteAll:DeleteAll deleteNonBlock:DeleteNonBlock)
end
```

- **相互排除(mutual exclusion)**
  - get-releaseロックを使う
  - 再入ロックを拡張
  - ロックの獲得と解放を定義
    - `Get`, `Release`

```
fun {NewGRLock}
  Token1={NewCell unit}
  Token2={NewCell unit}
  CurThr={NewCell unit}

  proc {GetLock}
    if {Thread.this}\=@CurThr then Old New in
       {Exchange Token1 Old New}
       {Wait Old}
       Token2:=New
       CurThr:={Thread.this}
    end
  end
  proc {ReleaseLock}
    CurThr:=unit
    unit=@Token2
  end
in
   ́lock ́(get:GetLock release:ReleaseLock)
end
```

- モニタ実装
  - `M.wait`が必ずアクティブlockの中で実行されることが条件
    - 実行時チェックを入れる
    - 静的に強制する言語抽象の中に実装を埋め込む
  - 状態共有並行モデルで並行プログラムを書くとき、モニタよりデータフローを使うほうが簡単
    - Mozartの実装ではモニタの性能の最適化をしてない
    - 下記実装も最適化可能

```
fun {NewMonitor}
  Q={NewQueue}
  L={NewGRLock}

  proc {LockM P}
    {L.get} try {P} finally {L.release} end
  end

  proc {WaitM} X in
    {Q.insert X} {L.release} {Wait X} {L.get}
  end

  proc {NotifyM}
  U={Q.deleteNonBlock} in
    case U of [X] then X=unit else skip end
  end
  
  proc {NotifyAllM}
  L={Q.deleteAll} in
    for X in L do X=unit end
  end
in
  monitor( ́lock ́:LockM wait:WaitM notify:NotifyM
          notifyAll:NotifyAllM)
end
```

### 8.4.5. モニタの別のSemantics

- `notify`の効果
  - 待機中の1つのスレッドがwait集合を離れるようにする
  - スレッドはモニタのlockを獲得しようとする
  - notifyを発するスレッドは直ちにモニタlockを手放さない(?:)
    - 手放したタイミングで、notifyを受けたスレッドはその他のスレッドとlockに入るのを争い始める
    - notifyが発せられた時点において真であった防護条件が、notifyを受けたスレッドがlockに入る時にもはや真でないかもしれない
      - lockに入ったスレッドが防護条件を再度チェックしなければならない
- より効率的かつ推論しやすい`notify`変種
  - 2つの操作をatomicに実行するようにする
    - 待機中の1つのスレッドをwait集合から出す
    - 直ちにモニタlockを取り出したスレッドにわたす
      - notifyを発したスレッドがモニタから出る
  - 防護条件が真であり続ける
  - notifyAllは不要になる
- 変種のように実装した言語では、複数のwait集合が宣言可能
  - wait集合: データ抽象としての防護条件のインスタンス(?:)
  - **防護条件変数(condition variable)** インスタンスを生成可能
    - 防護条件`c`が持つ操作
      - c.wait
      - c.notify

## 8.5. トランザクション

- 大規模共有DBを管理するための概念
  - 理想
    - データの首尾一貫性を保つ
    - システムクラッシュの影響を受けない
    - 激しい並行的更新に耐える
  - 理想が難しい理由
    - 仮定
      - DBをcellの配列とする
      - 多くのクライアントがDBを並行的に更新する
    - 素朴な実装: 1つのlockで配列全体を保護する
      - 非現実的
        - あるクライアントの操作中、他のクライアントは何も出来ないため
  - トランザクションで解決する
- **ACID**
  - **Atomicity**
    - トランザクションの実行に中間状態は無い
    - 起きるか起きないか
    - 正常に完了する(commit)か取り消される(abort)か
  - **Consistency**
    - 観測可能な状態変化がシステム不変表明を破らないこと
    - atomicとの密接な関係
      - consistency: プログラマの責任(?:アプリケーションレベルのtransactionが担保するのは操作のatomicityではなくこっちだった！)
      - atomicity: トランザクションシステムの実装の責任
  - **Isolation**
    - いくつかのトランザクションが並行に、相互に干渉すること無く実行すること
      - 直列であるかのように実行する
      - **直列化可能性(serializability)**
    - トランザクションがInterleaveSemanticsを持つ
      - 計算モデルのレベルからトランザクションのレベルに*引き上げて(lift)*使っている
  - **Durability**
    - 観測可能な状態変化が、システムをシャットダウンしても有効であること
    - Durability==Persistence
    - 永続性のあるストレージが必要
      - 観測可能な状態変化を格納できる

#### 軽量級トランザクション(ACI)

- DB以外ならACID属性全てが必要なわけではない
  - 凡用並行プログラミングに必要程度のもの
- **軽量級トランザクション(ACI)** と呼んで区別する
  - abort可能なatomicアクション
  - D以外の性質を備える
  - commit可能
  - abort可能
    - プログラム内部の理由
      - 共有データに対するアクセスの矛盾
    - プログラム外部の理由
      - ディスクやネットワークなど、システム起因の異常

#### 動機

- トランザクションを必要とする動機
  - 4つ
    - データベースへの並行アクセスの処理能力を増大する
    - 例外処理を行う並行プログラミングを実現する
    - フォールトトレランス
    - 資源管理
  - 例外処理を行う並行プログラミングを実現する
    - 大抵のルーチンの終わり方
      - 正常終了
        - atomicに振る舞う
        - ルーチンを呼ぶ側は初期状態と結果を見るだけ、途中は見ない
      - 例外を発生
        - 処理途中を意識せざるを得ない
        - 処理途中で例外を発したことで、ルーチンがシステムの一部を矛盾状態にする可能性
    - 解
      - 呼ぶ側がルーチンの後処理をする
        - 混乱、矛盾の範囲を制限するように、呼ぶ側が注意してプログラムする
      - ルーチンをトランザクションの中に置く
        - 実装が困難
        - プログラムが簡単になる
        - 例外発生: トランザクションのabort
  - フォールトトレランス
    - フォールト
      - コンポーネントにおいて、サブコンポーネントの1つの正しくない振る舞い
    - 理想
      - フォールトがあってもアプリは正しく振る舞い続けるべき
      - **フォールトトレランス**
    - フォールト発生時のアプリの振る舞い
      - フォールトを検出する
      - フォールトをアプリの限られた部分に封じ込める
      - フォールトによって引き起こされた問題を修復する
    - ACIはフォールトの影響範囲を限定するために有効
  - 資源管理
    - deadlockによるアプリの停止を避ける
    - 複数の資源獲得を可能に

- 核言語、計算モデルの視点から見たトランザクション
  - 拡張したモデルにおいて、プログラムが簡単になる判断基準
    - 計算モデルに概念を追加し、問題解決しているか
    - トランザクションの利用はこれを満たす
  - 解決したい問題に対して、追加したい概念は本当にトランザクションなのか？
    - 今後の研究課題
    - プログラミング言語の重要な部分になる

### 8.5.1. 並行性制御

- 多くのクライアントが同時にアクセスする大きなDB
  - トランザクションの観点から見ると
    - アクセスは並行である
    - 直列化可能性を満たす
  - 実装において担保すべきこと
    - トランザクションの並行な処理
    - 直列化可能であること
  - 同時に満たすのは困難
    - 多くの理論やアルゴリズムが生まれた
- **並行性制御**
  - トランザクション的性質を持つ並行システムの構築、プログラムに使う技法の集合

#### lockとタイムスタンプ

- 並行性制御に最も広く使われる技法
  - **lockベース並行性制御**
    - 状態あり実体はアクセスを制御するlockを持つ
      - eg. cellのlock
      - transactionがcellを使うには、そのcellのlockを持っていなければならない
    - 直列化可能性、安全性、Isolation、システム不変表明
      - lockが重要
  - **タイムスタンプベース並行性制御**
    - 優先順位を定めるタイムスタンプをトランザクションに与える
- 安全性と生存性
  - システムが時間の関数としてどのように振る舞うかを示す
    - `常に`、`いずれ`などの単語の意味に注意
  - いずれ真になることが常にある
    - 現在のステップから始まるどのステップもいずれ真になる
    - アクティブトランザクションはいずれabortするかcommitする
    - cf. 時相論理(temporal logic)

#### 楽観的スケジューリングと悲観的スケジューリング

- 楽観的スケジューリング
  - 飛行機の座席の例
    - オーバーブッキングが多い
      - たまに起きる問題、大目に見られる
      - 平均座席充填率が上がる
- 悲観的スケジューリング
  - 鉄道の例
    - ある区間を走る鉄道は必ず1つだけ
    - 空くまで待つ必要がある
- トランザクションがcellのlockを要求したときのスケジューラの挙動
  - 即座に叶える
    - 楽観的スケジューリング
  - 拒否する
    - トランザクションはabortする
  - 決定を延期する
    - 悲観的スケジューリング
  - 共有データに作用するトランザクションの頻度によって決めるべき
    - 多い: 悲観的がいい

#### 2相ロック

- lockを手放すのをトランザクションのcommit, abortのあとだけにする
  - abort雪崩を防ぐ

### 8.5.2. 簡易トランザクションマネージャ

#### デッドロック

- デッドロック対策
  - 予防
    - デッドロックの可能性があるオブジェクトをロックしようとすると妨げる
  - 治療
    - デッドロックの発生を検出、解消
- wait-forグラフの概念に基づく
  - 有向グラフ
  - アクティブ実体(トランザクション)と資源(cell)をノードとする
  - デッドロック: グラフの閉路に対応

